<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TypeScript类型基础1</title>
    <url>/2022/12/29/TypeScript%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%801/</url>
    <content><![CDATA[<h3 id="如何类型檫除"><a href="#如何类型檫除" class="headerlink" title="如何类型檫除"></a>如何类型檫除</h3><ol>
<li>esbuild (快 不检查ts语法)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g esbuild</span><br><span class="line">esbuild 1.ts &gt; 1.js</span><br></pre></td></tr></table></figure>

<ol>
<li>swc (快 不检查ts语法)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g @swc/cli @swc/core</span><br><span class="line">swc 1.ts -o 1.js</span><br></pre></td></tr></table></figure>

<ol>
<li>typescript(慢 检查ts语法)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i -g typescript</span><br><span class="line">tsc 1.ts</span><br></pre></td></tr></table></figure>

<ol>
<li>bable(慢 检查ts语法)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i @babel/core @babel/cli @babel/preset-typescript</span><br><span class="line">babel --presets @babel/preset-typescript 1.ts</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>js八种数据类型 <code>null</code>、<code>undefined</code>、<code>string</code>、<code>number</code> <code>boolean</code> <code>bigint</code> <code>symbol</code> <code>object</code></p>
<p>ts类型 js的类型加上： <code>void</code> <code>never</code> <code>enum</code> <code>unkonwn</code> <code>any</code> <code>type</code> <code>interface</code></p>
<h1 id="用类型签名和Record描述对象"><a href="#用类型签名和Record描述对象" class="headerlink" title="用类型签名和Record描述对象"></a>用类型签名和Record描述对象</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">number</span> <span class="comment">//  索引签名</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">Record</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; <span class="comment">// 泛型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="title class_">Object</span> = <span class="number">1</span>;  <span class="comment">// 包装对象的原因导致这里不报错</span></span><br></pre></td></tr></table></figure>

<p>由于Object太不精确，ts一般使用索引签名和Record泛型描述普通对象。</p>
<h3 id="用-和Array泛型描述数组"><a href="#用-和Array泛型描述数组" class="headerlink" title="用 [] 和Array泛型描述数组"></a>用 [] 和Array泛型描述数组</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = <span class="built_in">string</span>[]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A1</span> = <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">A2</span> = [<span class="built_in">string</span> <span class="built_in">string</span>]</span><br></pre></td></tr></table></figure>

<h3 id="描述函数对象"><a href="#描述函数对象" class="headerlink" title="描述函数对象"></a>描述函数对象</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FnA</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FnVoid</span> = <span class="function">() =&gt;</span> <span class="built_in">void</span> <span class="comment">// 没有返回值  一般没有返回值用这种写法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">FnUndefined</span> = <span class="function">() =&gt;</span> <span class="literal">undefined</span> <span class="comment">// 必须返回undefined</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由于Function太不精确，ts一般使用()&#x3D;&gt;?描述函数。</p>
<h3 id="描述其他对象"><a href="#描述其他对象" class="headerlink" title="描述其他对象"></a>描述其他对象</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">d</span>: <span class="title class_">Date</span> = <span class="keyword">new</span> <span class="title class_">Date</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">r</span>: <span class="title class_">RegExp</span> = <span class="regexp">/ab+c/</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">m</span>:<span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> <span class="title class_">Map</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">wm</span>: <span class="title class_">WeakMap</span>&lt;&#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125;, <span class="built_in">number</span>&gt; = <span class="keyword">new</span> <span class="title class_">WeakMap</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">s</span>: <span class="title class_">Set</span>&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> <span class="title class_">Set</span>()</span><br><span class="line"><span class="keyword">const</span> <span class="attr">ws</span>: <span class="title class_">WeakSet</span>&lt;<span class="built_in">string</span>[]&gt; = <span class="keyword">new</span> <span class="title class_">WeakSet</span>()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="any-amp-unknown"><a href="#any-amp-unknown" class="headerlink" title="any&amp;unknown"></a>any&amp;unknown</h3><ul>
<li>可以将任何东西赋给 <code>unknown</code> 类型，但在进行类型检查或类型断言之前，不能对 <code>unknown</code> 进行操作</li>
<li>可以把任何东西分配给<code>any</code>类型，也可以对<code>any</code>类型进行任何操作</li>
</ul>
<p>一般不用<code>any</code>，推荐用<code>unknown</code>, 因为使用 <code>unknown</code> 类型前，必须进行类型断言</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="attr">a</span>: <span class="built_in">any</span> = <span class="number">1</span>;</span><br><span class="line">a.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">b</span>: <span class="built_in">unknown</span> = <span class="number">2</span>;</span><br><span class="line">(b <span class="keyword">as</span> <span class="built_in">number</span>).<span class="title function_">toFixed</span>(<span class="number">2</span>) <span class="comment">// 使用前必须进行断言处理</span></span><br></pre></td></tr></table></figure>

<h3 id="枚举和位操作"><a href="#枚举和位操作" class="headerlink" title="枚举和位操作"></a>枚举和位操作</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Permission</span> &#123;</span><br><span class="line">  <span class="title class_">Read</span> = <span class="number">1</span> &lt;&lt; <span class="number">0</span>, <span class="comment">// 0001</span></span><br><span class="line">  <span class="title class_">Write</span> = <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">// 0010</span></span><br><span class="line">  <span class="title class_">Delete</span> = <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">// 0100</span></span><br><span class="line">  <span class="title class_">Manage</span> = <span class="title class_">Read</span> | <span class="title class_">Write</span> | <span class="title class_">Delete</span>, <span class="comment">// 0111</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">user</span>: &#123;<span class="attr">perssion</span>: <span class="title class_">Permission</span>&#125; = &#123;<span class="attr">perssion</span>: <span class="number">0b0101</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((user.<span class="property">perssion</span> &amp; <span class="title class_">Permission</span>.<span class="property">Write</span>) === <span class="title class_">Permission</span>.<span class="property">Write</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;有写权限&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="type与interface的前两个区别"><a href="#type与interface的前两个区别" class="headerlink" title="type与interface的前两个区别"></a>type与interface的前两个区别</h3><p>带有属性的函数的声明方式</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">FnWithProp</span> = &#123;</span><br><span class="line">  (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">prop</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">f</span>: <span class="title class_">FnWithProp</span> = <span class="function">(<span class="params">x, y</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.<span class="property">prop</span> = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>type &amp; interface 相同点</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> X &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; &amp; &#123;<span class="attr">name</span>: <span class="built_in">string</span>&#125; &amp; X</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> A2 <span class="keyword">extends</span> <span class="title class_">Array</span>&lt;<span class="built_in">string</span>&gt; , X &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ol>
<li>type 描述所有数据 interface 只描述对象</li>
<li>type 只是别名 interface 是类型声明</li>
<li>对外API 尽量用interface方便扩展；对内API尽量用type 防止代码分散</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">global</span> &#123;</span><br><span class="line">  <span class="keyword">interface</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="title function_">padZero</span>(<span class="attr">x</span>: <span class="built_in">string</span>) :<span class="built_in">void</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line">a.<span class="title function_">padZero</span>()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Javascript内存泄漏</title>
    <url>/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    <content><![CDATA[<p>分析下网上常说的几种Javascript内存泄漏方式，前置知识：Javascript内存回收方式是标记清除法。</p>
<h2 id="常见的内存泄漏方式分析"><a href="#常见的内存泄漏方式分析" class="headerlink" title="常见的内存泄漏方式分析"></a>常见的内存泄漏方式分析</h2><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>全局变量标记不能被清除，会一直占用内存</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  test1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;isboyjc1&#x27;</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">test2</span> = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;isboyjc2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
<img src="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/01.png" class="lazy" data-srcset="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p>局部变量没有引用会再下次gc时被清除</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> test1 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;isboyjc1&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> test2 = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10000000</span>).<span class="title function_">fill</span>(<span class="string">&#x27;isboyjc2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>()</span><br></pre></td></tr></table></figure>
<img src="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/02.png" class="lazy" data-srcset="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<h3 id="游离DOM引用"><a href="#游离DOM引用" class="headerlink" title="游离DOM引用"></a>游离DOM引用</h3><p>代码中进行 DOM 时会使用变量缓存 DOM 节点的引用，但移除节点的时候，我们应该同步释放缓存的引用，否则游离的子树无法释放。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;ul&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">&quot;li3&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> root = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#root&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> ul = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#ul&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">let</span> li3 = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;#li3&#x27;</span>)</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 由于ul变量存在，整个ul及其子元素都不能GC</span></span></span><br><span class="line"><span class="language-javascript">  root.<span class="title function_">removeChild</span>(ul)</span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 虽置空了ul变量，但由于li3变量引用ul的子节点，所以ul元素依然不能被GC</span></span></span><br><span class="line"><span class="language-javascript">  ul = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript">  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// 已无变量引用，此时可以GC</span></span></span><br><span class="line"><span class="language-javascript">  li3 = <span class="literal">null</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="未清理的console"><a href="#未清理的console" class="headerlink" title="未清理的console"></a>未清理的console</h3><p>浏览器保存了对象的引用，未清理的 <code>console</code> 如果输出了对象也会造成内存泄漏</p>
<h3 id="遗忘的定时器和事件监听器"><a href="#遗忘的定时器和事件监听器" class="headerlink" title="遗忘的定时器和事件监听器"></a>遗忘的定时器和事件监听器</h3><p><code>addEventListener</code>、<code>setTimeout</code> 、 <code>setInterval</code>和<code>requestAnimationFrame</code>等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="variable language_">this</span>.<span class="property">doSomething</span>)</span><br><span class="line"> <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&quot;resize&quot;</span>, <span class="variable language_">this</span>.<span class="property">doSomething</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> someResource = <span class="title function_">getData</span>()</span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;Node&#x27;</span>)</span><br><span class="line">	<span class="keyword">if</span>(node) &#123;</span><br><span class="line">    node.<span class="property">innerHTML</span> = <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(someResource))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><strong>闭包并不会引发内存泄漏</strong><br>由于IE9 之前的版本对JScript 对象和COM 对象使用不同的垃圾收集。因此闭包在IE 的这些版本中会导致一些特殊的问题。具体来说，如果闭包的作用域链中保存着一个HTML 元素，那么就意味着该元素将无法被销毁：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">assignHandler</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> element = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;someElement&quot;</span>);</span><br><span class="line">  element.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(element.<span class="property">id</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看两个例子反证一下：</p>
<img src="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/03.png" class="lazy" data-srcset="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/03.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">
<img src="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/04.png" class="lazy" data-srcset="/2023/03/16/Javascript%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/04.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<h2 id="内存监测"><a href="#内存监测" class="headerlink" title="内存监测"></a>内存监测</h2><h3 id="Performance-memory-已弃用"><a href="#Performance-memory-已弃用" class="headerlink" title="Performance.memory(已弃用)"></a>Performance.memory(已弃用)</h3><p>浏览器在 <code>performance</code> 对象上加上了 <code>memory</code> 属性，通过获取 <code>performance.memory</code> 可以得到一组当前页面使用内存数据的信息。具体如下：</p>
<ul>
<li><code>jsHeapSizeLimit</code>：表示当前页面最多可以获得的 JavaScript 堆大小；</li>
<li><code>totalJSHeapSize</code>：表示当前页面已经分配的 JavaScript 堆大小；</li>
<li><code>usedJsHeapSize</code>：表示当前页面 JavaScript 已经使用的堆大小。</li>
</ul>
<p>这里，三个值的单位是字节（byte），且有恒定的不等式：<code>jsHeapSizeLimit</code> &gt;&#x3D; <code>totalJSHeapSize</code> &gt;&#x3D; <code>usedJsHeapSize</code>。</p>
<p>浏览器在分配内存的时候，会一次性向系统申请一块内存，然后在 JavaScript 需要的时候直接提供使用，因而 <code>totalJSHeapSize</code> 总是大于 <code>usedJsHeapSize</code> 的。如果 JavaScript 需要的内存多于已经申请的量，就会继续申请一块，直到达到 <code>jsHeapSizeLimit</code> 的上限，触发页面崩溃。</p>
<p>通过观察 <code>jsHeapSizeLimit</code> 和 <code>totalJSHeapSize</code> 这两个字段，可以用于监控当前的页面是否有耗尽内存的危险；同时，如果内存一直在涨，不见回落，很可能需要排查是否有潜在的内存泄漏危险。</p>
<p>需要注意的几点：</p>
<ol>
<li><p>出于安全方面的考虑，API 并不会给出非常准确的数据，并且给出的数据会额外加上一些干扰(<a href="https://github.com/WICG/performance-memory/blob/master/explainer.md#security">参考这个</a>，以及这个<a href="https://bugs.webkit.org/attachment.cgi?id=154876&action=prettypatch">改动</a>)；<br>(经过测试定时1s获取是可以的，40ms则不行)</p>
</li>
<li><p>如果需要 Chrome 给出精确的内存数据，可以在启动的时候加上 –enable-precise-memory-info；</p>
</li>
<li><p><code>performance.memory</code> 无法通过 <code>JSON.stringify</code> 获取到数据（结果是 <code>&#123;&#125;</code>），一些分析和解决办法可以参考<a href="https://medium.com/@iamoryanmoshe/the-object-that-misbehaved-window-performance-memory-fe338736aed0">这篇文章</a>。</p>
</li>
</ol>
<h3 id="performance-measureUserAgentSpecificMemory"><a href="#performance-measureUserAgentSpecificMemory" class="headerlink" title="performance.measureUserAgentSpecificMemory()"></a>performance.measureUserAgentSpecificMemory()</h3><p>周期调用以跟踪内存使用情况在会话期间的变化情况。</p>
<p><strong>安全要求</strong>需要在响应头中开启这个</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">Cross-Origin-Opener-Policy: same-origin</span><br><span class="line">Cross-Origin-Embedder-Policy: require-corp</span><br></pre></td></tr></table></figure>
<p>可以这样监测跨源隔离是否成功</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (crossOriginIsolated) &#123;</span><br><span class="line">  <span class="comment">// Use measureUserAgentSpecificMemory</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>监视内存使用情况</strong> ：可以使用指数分布随机每隔五分钟调用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">runMemoryMeasurements</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> interval = -<span class="title class_">Math</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>()) * <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Next measurement in <span class="subst">$&#123;<span class="built_in">Math</span>.round(interval / <span class="number">1000</span>)&#125;</span> seconds.`</span>);</span><br><span class="line">  <span class="built_in">setTimeout</span>(measureMemory, interval);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">measureMemory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> memorySample = <span class="keyword">await</span> performance.<span class="title function_">measureUserAgentSpecificMemory</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(memorySample);</span><br><span class="line">  <span class="title function_">runMemoryMeasurements</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (crossOriginIsolated) &#123;</span><br><span class="line">  <span class="title function_">runMemoryMeasurements</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>主要区别在于 <code>performance.memory</code> 返回 JavaScript 堆的大小，而 <code>performance.measureUserAgentSpecificMemory</code> 只返回当前网页使用的内存。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://juejin.cn/post/6984188410659340324#heading-4">你的程序中可能存在内存泄漏</a></li>
<li><a href="https://www.finclip.com/news/f/296.html">闭包会造成内存泄漏吗？</a></li>
<li><a href="https://web.dev/effectivemanagement/">有效管理 Gmail 规模的内存</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/memory">Performance.memory</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Performance/measureUserAgentSpecificMemory">performance.measureUserAgentSpecificMemory</a></li>
<li><a href="https://segmentfault.com/a/1190000039415942">了不起的Chrome浏览器：Chrome 89开启Web应用的物联网时代</a></li>
<li><a href="https://web.dev/monitor-total-page-memory-usage/">monitor-total-page-memory-usage</a></li>
<li><a href="https://laysent.com/til/2019-12-30_performance-memory">Performance Memory</a></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript内存知识</title>
    <url>/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<blockquote>
<p>由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。  –《JavaScript权威指南（第四版）》</p>
</blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>像 C 语言这样的底层语言一般都有底层的内存管理接口，比如 malloc()和free()。相反，JavaScript 是在创建变量（对象，字符串等）时自动进行了分配内存，并且在不使用它们时“自动”释放。释放的过程称为垃圾回收。</p>
<h3 id="内存生命周期"><a href="#内存生命周期" class="headerlink" title="内存生命周期"></a>内存生命周期</h3><p>不管什么程序语言，内存生命周期基本是一致的：</p>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/01.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<ol>
<li><strong>内存分配</strong> – 分配你所需要的内存</li>
<li><strong>内存使用</strong> – 使用分配到的内存（读、写）</li>
<li><strong>内存释放</strong> — 释放你明确不需要的内存，让其再次空闲和可用。</li>
</ol>
<h3 id="JavaScript-的内存分配"><a href="#JavaScript-的内存分配" class="headerlink" title="JavaScript 的内存分配"></a>JavaScript 的内存分配</h3><h4 id="值的初始化"><a href="#值的初始化" class="headerlink" title="值的初始化"></a>值的初始化</h4><p>JavaScript 在定义变量时就完成了内存分配。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> n = <span class="number">123</span>; <span class="comment">// 给数值变量分配内存</span></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>; <span class="comment">// 给字符串分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="literal">null</span></span><br><span class="line">&#125;; <span class="comment">// 给对象及其包含的值分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给数组及其包含的值分配内存（就像对象一样）</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="literal">null</span>, <span class="string">&quot;abra&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">2</span>;</span><br><span class="line">&#125; <span class="comment">// 给函数（可调用的对象）分配内存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式也能分配一个对象</span></span><br><span class="line">someElement.<span class="title function_">addEventListener</span>(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">  someElement.<span class="property">style</span>.<span class="property">backgroundColor</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="通过函数调用分配内存"><a href="#通过函数调用分配内存" class="headerlink" title="通过函数调用分配内存"></a>通过函数调用分配内存</h4><p>有些函数调用结果是分配对象内存：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Date</span>(); <span class="comment">// 分配一个 Date 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> e = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>); <span class="comment">// 分配一个 DOM 元素</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>有些方法分配新变量或者新对象：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&quot;azerty&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> s2 = s.<span class="title function_">substr</span>(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// s2 是一个新的字符串</span></span><br><span class="line"><span class="comment">// 因为字符串是不变量，</span></span><br><span class="line"><span class="comment">// JavaScript 可能决定不分配内存，</span></span><br><span class="line"><span class="comment">// 只是存储了 [0-3] 的范围。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">&quot;ouais ouais&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a2 = [<span class="string">&quot;generation&quot;</span>, <span class="string">&quot;nan nan&quot;</span>];</span><br><span class="line"><span class="keyword">var</span> a3 = a.<span class="title function_">concat</span>(a2);</span><br><span class="line"><span class="comment">// 新数组有四个元素，是 a 连接 a2 的结果</span></span><br></pre></td></tr></table></figure>
<h4 id="使用值"><a href="#使用值" class="headerlink" title="使用值"></a>使用值</h4><p>使用值的过程实际上是对分配内存进行读取与写入的操作。读取与写入可能是写入一个变量或者一个对象的属性值，甚至传递函数的参数。</p>
<h4 id="当内存不再需要使用时释放"><a href="#当内存不再需要使用时释放" class="headerlink" title="当内存不再需要使用时释放"></a>当内存不再需要使用时释放</h4><p>大多数内存管理的问题都在这个阶段。在这里最艰难的任务是找到“哪些被分配的内存确实已经不再需要了”。它往往要求开发人员来确定在程序中哪一块内存不再需要并且释放它。</p>
<p>高级语言解释器嵌入了“垃圾回收器”，它的主要工作是跟踪内存的分配和使用，以便当分配的内存不再使用时，自动释放它。这只能是一个近似的过程，因为要知道是否仍然需要某块内存是无法判定的（无法通过某种算法解决）。</p>
<h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>自动寻找是否一些内存“不再需要”的问题是无法判定的。因此，垃圾回收实现只能有限制的解决一般问题。主要的垃圾回收算法都有局限性。</p>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>这是最初级的垃圾收集算法。此算法把“对象是否不再需要”简化定义为“对象有没有其他对象引用到它”。如果没有引用指向该对象（零引用），对象将被垃圾回收机制回收。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];  <span class="comment">// [1, 2, 3, 4] 被变量arr引用, 引用次数+1 =&gt; 1</span></span><br><span class="line">arr = <span class="function">() =&gt;</span> &#123;&#125;;  <span class="comment">// 变量arr 引用了一个函数， [1, 2, 3, 4] 引用次数-1 =&gt; 0  [1, 2, 3, 4]占用空间被回收</span></span><br></pre></td></tr></table></figure>
<p><strong>问题</strong>：循环引用</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> obj1 = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">  obj1.<span class="property">a</span> = obj2; <span class="comment">// o 引用 o2</span></span><br><span class="line">  obj2.<span class="property">a</span> = obj1; <span class="comment">// o2 引用 o</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">f</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。</p>
<p>要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj1 = <span class="literal">null</span>;</span><br><span class="line">obj2 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>

<h4 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h4><p>定期执行以下“垃圾回收”步骤：</p>
<ul>
<li>垃圾收集器找到所有的根，并“标记”（记住）它们。</li>
<li>然后它遍历并“标记”来自它们的所有引用。</li>
<li>然后它遍历标记的对象并标记 它们的 引用。所有被遍历到的对象都会被记住，以免将来再次遍历到同一个对象。</li>
<li>……如此操作，直到所有可达的（从根部）引用都被访问到。</li>
<li>没有被标记的对象都会被删除。</li>
</ul>
<p>JavaScript 中主要的内存管理概念是 <strong>可达性</strong>。</p>
<p>简而言之，“可达”值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p>
<p><strong>一个简单的例子</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// user 具有对这个对象的引用</span></span><br><span class="line"><span class="keyword">let</span> user = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/02.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p>变量 <code>&quot;user&quot;</code> 引用了对象 <code>&#123;name：&quot;John&quot;&#125;</code></p>
<p>如果 <code>user</code> 的值被重写了，这个引用就没了：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">user = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/03.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/03.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">
<p>对象<code>&#123;name：&quot;John&quot;&#125;</code>变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。</p>
<p><strong>相互关联的对象</strong><br>一个更复杂的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">marry</span>(<span class="params">man, woman</span>) &#123;</span><br><span class="line">  woman.<span class="property">husband</span> = man;</span><br><span class="line">  man.<span class="property">wife</span> = woman;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">father</span>: man,</span><br><span class="line">    <span class="attr">mother</span>: woman</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> family = <span class="title function_">marry</span>(&#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;John&quot;</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Ann&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><code>marry</code> 函数通过让两个对象相互引用使它们“结婚”了，并返回了一个包含这两个对象的新对象。</p>
<p>由此产生的内存结构：</p>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/04.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/04.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p>到目前为止，所有对象都是可达的。</p>
<p>现在让我们移除两个引用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> family.<span class="property">father</span>;</span><br><span class="line"><span class="keyword">delete</span> family.<span class="property">mother</span>.<span class="property">husband</span>;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/05.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/05.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p>仅删除这两个引用中的一个是不够的，因为所有的对象仍然都是可达的。</p>
<p>但是，如果我们把这两个都删除，那么我们可以看到再也没有对 John 的引用了：</p>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/06.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/06.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p>对外引用不重要，只有传入引用才可以使对象可达。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。</p>
<p>经过垃圾回收：</p>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/07.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/07.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<p><strong>无法到达的岛屿</strong><br>几个对象相互引用，但外部没有对其任意对象的引用，这些对象也可能是不可达的，并被从内存中删除。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">family = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<img src="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/08.png" class="lazy" data-srcset="/2023/03/15/JavaScript%E5%86%85%E5%AD%98%E7%9F%A5%E8%AF%86/08.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">


<p><strong>优化措施</strong></p>
<ul>
<li><strong>分代收集（Generational collection）</strong>—— 对象被分成两组：“新的”和“旧的”。在典型的代码中，许多对象的生命周期都很短：它们出现、完成它们的工作并很快死去，因此在这种情况下跟踪新对象并将其从内存中清除是有意义的。那些长期存活的对象会变得“老旧”，并且被检查的频次也会降低。</li>
<li><strong>增量收集（Incremental collection）</strong>—— 如果有许多对象，并且我们试图一次遍历并标记整个对象集，则可能需要一些时间，并在执行过程中带来明显的延迟。因此，引擎将现有的整个对象集拆分为多个部分，然后将这些部分逐一清除。这样就会有很多小型的垃圾收集，而不是一个大型的。这需要它们之间有额外的标记来追踪变化，但是这样会带来许多微小的延迟而不是一个大的延迟。</li>
<li><strong>闲时收集（Idle-time collection）</strong>—— 垃圾收集器只会在 CPU 空闲时尝试运行，以减少可能对代码执行的影响。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management">内存管理</a></li>
<li><a href="https://zh.javascript.info/garbage-collection">垃圾回收</a></li>
</ol>
]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>go学习笔记</title>
    <url>/2022/07/11/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="go基本命令"><a href="#go基本命令" class="headerlink" title="go基本命令"></a>go基本命令</h3><ul>
<li>go get: 获取远程包（需要提取安装git或gh）</li>
<li>go run: 直接运行程序</li>
<li>go build: 测试编译，检查编译是否有错误</li>
<li>go fmt: 格式化源码</li>
<li>go install: 编译包文件并编译整个程序</li>
<li>go test: 运行测试文件（文件以_test.go结尾的默认为测试文件）</li>
<li>go doc: 查看文档</li>
</ul>
<h3 id="Go-modules"><a href="#Go-modules" class="headerlink" title="Go modules"></a>Go modules</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启用 Go Modules 功能</span></span><br><span class="line">export GO111MODULE=on</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置 GOPROXY 环境变量</span></span><br><span class="line">export GOPROXY=https://goproxy.io</span><br></pre></td></tr></table></figure>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p><code>new()</code> 内建函数取指针，相当于结构体初始化后取指针，写法更简洁一些。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DB <span class="keyword">struct</span> &#123;</span><br><span class="line">	name1 <span class="type">uint64</span></span><br><span class="line">	name2 <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestNew</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	p0 := <span class="built_in">new</span>(DB)</span><br><span class="line">	<span class="keyword">var</span> p1 DB</span><br><span class="line">	p2 := &amp;p1</span><br><span class="line">	t.Log(unsafe.Offsetof(p0.name1))</span><br><span class="line">	t.Log(unsafe.Offsetof(p0.name2))</span><br><span class="line">	t.Log(unsafe.Offsetof(p2.name1))</span><br><span class="line">	t.Log(unsafe.Offsetof(p2.name2))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a><strong><strong>互斥锁</strong></strong></h3><p><code>sync.Mutex</code>是一个互斥锁，可以由不同的goroutine加锁和解锁。</p>
<p>Go标准库提供了<code>sync.Mutex</code>互斥锁类型以及两个方法分别是<code>Lock</code>加锁和<code>Unlock</code>释放锁。可以通过在代码前调用<code>Lock</code>方法，在代码后调用<code>Unlock</code>方法来保证一段代码的互斥执行，也可以使用<code>defer</code>语句来保证互斥锁一定会被解锁。当一个<code>goroutine</code>调用<code>Lock</code>方法获得锁后，其它请求的<code>goroutine</code>都会阻塞在<code>Lock</code>方法直到锁被释放。</p>
<p>一个互斥锁只能同时被一个<code>goroutine</code>锁定，其它<code>goroutine</code>将阻塞直到互斥锁被解锁，也就是重新争抢对互斥锁的锁定。需要注意的是，对一个未锁定的互斥锁解锁时将会产生运行时错误。</p>
<p><code>sync.Mutex</code>不区分读写锁，只有<code>Lock()</code>和<code>Lock()</code>之间才会导致阻塞的情况。</p>
<p>有互斥锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"><span class="keyword">var</span> set = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOnce</span><span class="params">(index <span class="type">int</span>, num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> _, ok := set[num]; !ok &#123;</span><br><span class="line">		fmt.Println(index, num)</span><br><span class="line">	&#125;</span><br><span class="line">	set[num] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPrint</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> printOnce(i, <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 100</span></span><br><span class="line"><span class="comment">// 2 100</span></span><br></pre></td></tr></table></figure>

<p>没有互斥锁</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> test</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m sync.Mutex</span><br><span class="line"><span class="keyword">var</span> set = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">bool</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printOnce</span><span class="params">(index <span class="type">int</span>, num <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	<span class="keyword">defer</span> m.Unlock()</span><br><span class="line">	<span class="keyword">if</span> _, ok := set[num]; !ok &#123;</span><br><span class="line">		fmt.Println(index, num)</span><br><span class="line">	&#125;</span><br><span class="line">	set[num] = <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestPrint</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> printOnce(i, <span class="number">100</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 100</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript类型基础2</title>
    <url>/2023/01/05/TypeScript%E7%B1%BB%E5%9E%8B%E5%9F%BA%E7%A1%802/</url>
    <content><![CDATA[<h3 id="类型收窄"><a href="#类型收窄" class="headerlink" title="类型收窄"></a>类型收窄</h3><ol>
<li>使用typeof区分类型</li>
</ol>
<p>局限性: 数组对象、普通对象、日期对象、<code>null</code>都返回 <code>&#39;object&#39;</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: <span class="built_in">number</span> | <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;number&quot;</span>) &#123;</span><br><span class="line">    a.<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol>
<li>使用instanceof区分类型</li>
</ol>
<p>局限性：不支持<code>string</code>  <code>number</code> <code>boolean</code>等基本类型和不支持ts独有的类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: <span class="built_in">Array</span>&lt;<span class="built_in">Date</span>&gt; | <span class="built_in">Date</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Date</span>) &#123;</span><br><span class="line">    a.<span class="title function_">toISOString</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> <span class="title class_">Array</span>) &#123;</span><br><span class="line">    a[<span class="number">0</span>].<span class="title function_">toDateString</span>()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;never do this&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>使用 in 来收窄类型：只适用部分对象</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: Person | Person[]</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> a) &#123;</span><br><span class="line">    a; <span class="comment">// Person</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a; <span class="comment">// Person[]</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li>类型谓词 is</li>
</ol>
<p>有点：支持所有的ts类型</p>
<p>缺点：麻烦</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Rect</span> = &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Circle</span> = &#123;</span><br><span class="line">  <span class="attr">center</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">isRect</span>(<span class="params">x: Rect | Circle</span>): x is <span class="title class_">Rect</span> &#123; <span class="comment">// 不能是箭头函数也不能返回boolean类型</span></span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;height&quot;</span> <span class="keyword">in</span> x &amp;&amp; <span class="string">&quot;width&quot;</span> <span class="keyword">in</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: Rect | Circle</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">isRect</span>(a)) &#123;</span><br><span class="line">    a <span class="comment">// Rect</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>可辨别联合 x.kind</li>
</ol>
<p>联合类型有一个同名、可辨别的简单类型</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Rect</span> = &#123;</span><br><span class="line">  <span class="attr">height</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">width</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;rect&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Circle</span> = &#123;</span><br><span class="line">  <span class="attr">center</span>: [<span class="built_in">number</span>, <span class="built_in">number</span>];</span><br><span class="line">  <span class="attr">radius</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="attr">kind</span>: <span class="string">&#x27;circle&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: Rect | Circle</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (a.<span class="property">kind</span> === <span class="string">&#x27;rect&#x27;</span>) &#123;</span><br><span class="line">    a <span class="comment">// Rect</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="重新看待any-amp-unknown"><a href="#重新看待any-amp-unknown" class="headerlink" title="重新看待any&amp;unknown"></a>重新看待any&amp;unknown</h3><p>any是所有的类型，随用随变，用了相当于没有用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: <span class="built_in">any</span></span>) =&gt; &#123;</span><br><span class="line">  a.<span class="title function_">toFixed</span>()</span><br><span class="line">  a.<span class="title function_">split</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>unkown 是所有类型的联合</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">f</span> = (<span class="params">a: <span class="built_in">unknown</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> a === <span class="string">&quot;string&quot;</span>) &#123;</span><br><span class="line">    a <span class="comment">// string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="交叉类型的特殊场景"><a href="#交叉类型的特殊场景" class="headerlink" title="交叉类型的特殊场景"></a>交叉类型的特殊场景</h3><p>类型交叉时，属性冲突，属性取交集</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">User</span> = <span class="title class_">Person</span> &amp; &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">u</span>:<span class="title class_">User</span> = &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="number">1</span>, <span class="comment">// never</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>interface不能继承时，属性不能冲突，会报错</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_">Person</span>  &#123; <span class="comment">// 报错</span></span><br><span class="line">  <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>态度：重载没什么特别的用处，正常起两个函数名字就可以</p>
<p>如果封装的是一个底层的库，重载相当于把复杂度留给了自己，方便了使用者；具体用不用，要看想把复杂度留给谁去处理。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">string</span>, arg2: <span class="built_in">string</span></span>): <span class="built_in">string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">number</span>, arg2: <span class="built_in">number</span></span>): <span class="built_in">number</span></span><br><span class="line"><span class="comment">// 实现 参数类型兼容声明中的所有写法：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">arg1: <span class="built_in">string</span> | <span class="built_in">number</span>, arg2: <span class="built_in">string</span> | <span class="built_in">number</span></span>): <span class="built_in">string</span> | <span class="built_in">number</span> &#123;</span><br><span class="line">   <span class="comment">// 在实现上我们要注意严格判断两个参数的类型是否相等，而不能简单的写一个 arg1 + arg2</span></span><br><span class="line">   <span class="keyword">if</span>(<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">typeof</span> arg1 === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> arg2 === <span class="string">&#x27;number&#x27;</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> arg1 + arg2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="类型兼容"><a href="#类型兼容" class="headerlink" title="类型兼容"></a>类型兼容</h3><p>普通对象(属性少的兼容属性多的)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> A = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">a</span>: B = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">b</span>:A = a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口兼容(子接口兼容父接口|属性多的接口兼容属性少的接口)</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> P &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> P &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">p</span>: P;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">c</span>: C = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">12</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">p = c</span><br></pre></td></tr></table></figure>

<p>函数兼容</p>
<p>参数少的函数可以赋值给参数多的函数， 反之不行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">string</span></span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params">a: <span class="built_in">number</span></span>) =&gt; &#123;&#125;;</span><br><span class="line">a = b</span><br></pre></td></tr></table></figure>

<p>参数要求少的兼容参数要求多的，反之不行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> P &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> C <span class="keyword">extends</span> P &#123;</span><br><span class="line">  <span class="attr">age</span>: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params">a: P</span>) =&gt; &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params">a: C</span>) =&gt; &#123;&#125;;</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p>返回值属性少的兼容返回值属性多的，反之不行</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title function_">a</span> = (<span class="params"></span>) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>&#125;)</span><br><span class="line"><span class="keyword">let</span> <span class="title function_">b</span> = (<span class="params"></span>) =&gt; (&#123;<span class="attr">name</span>: <span class="string">&#x27;&#x27;</span>, <span class="attr">age</span>: <span class="number">12</span>&#125;)</span><br><span class="line"></span><br><span class="line">a = b</span><br></pre></td></tr></table></figure>

<h3 id="声明函数的4种方式"><a href="#声明函数的4种方式" class="headerlink" title="声明函数的4种方式"></a>声明函数的4种方式</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.先写类型再赋值</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="attr">f1</span>: <span class="variable constant_">F1</span> = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b;</span><br><span class="line"><span class="comment">// 2. 先实现箭头函数 再获取类型</span></span><br><span class="line"><span class="keyword">const</span> f2 = (<span class="attr">a</span>: <span class="built_in">number</span>, <span class="attr">b</span>: <span class="built_in">number</span>): <span class="function"><span class="params">number</span> =&gt;</span> a + b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 先实现普通函数再获取类型</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f3</span>(<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F3</span> = <span class="keyword">typeof</span> f3;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 先实现匿名普通函数 再获取类型</span></span><br><span class="line"><span class="keyword">const</span> f4 = <span class="keyword">function</span> (<span class="params"><span class="variable language_">this</span>: <span class="built_in">unknown</span>, a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">F4</span> = <span class="keyword">typeof</span> f4;</span><br></pre></td></tr></table></figure>

<h3 id="深入对象语法"><a href="#深入对象语法" class="headerlink" title="深入对象语法"></a>深入对象语法</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 索引签名</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Hash1</span>= &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">string</span>]: <span class="built_in">unknown</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">List1</span>   = &#123;</span><br><span class="line">  [<span class="attr">k</span>: <span class="built_in">number</span>]: <span class="built_in">unknown</span></span><br><span class="line">  <span class="attr">length</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 映射类型</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Hash</span> = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> <span class="built_in">string</span>]: <span class="built_in">unknown</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">List</span>   = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> <span class="built_in">number</span>]: <span class="built_in">unknown</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="泛型入门"><a href="#泛型入门" class="headerlink" title="泛型入门"></a>泛型入门</h3><p>基本使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Union</span>&lt;A, B&gt; = A | B</span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">Union</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">List</span>&lt;A&gt; &#123;</span><br><span class="line">  [<span class="attr">index</span>: <span class="built_in">number</span>] : A</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> D = <span class="title class_">List</span>&lt;<span class="built_in">string</span>&gt;</span><br><span class="line"><span class="comment">// 代入法</span></span><br><span class="line"><span class="comment">// interface List&lt;string&gt; &#123;</span></span><br><span class="line"><span class="comment">//   [index: number] : string</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>条件类型</p>
<p>在泛型中使用extends</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">LikeString</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">string</span> ? <span class="literal">true</span> : <span class="literal">false</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">LikeNumber</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">number</span> ? <span class="number">1</span> : <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R1</span> = <span class="title class_">LikeString</span>&lt;<span class="string">&#x27;hi&#x27;</span>&gt; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">R2</span> = <span class="title class_">LikeString</span>&lt;<span class="number">2</span>&gt; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S1</span> = <span class="title class_">LikeNumber</span>&lt;<span class="number">33</span>&gt; <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">S2</span> = <span class="title class_">LikeNumber</span>&lt;<span class="literal">false</span>&gt; <span class="comment">// 2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>若T为联合类型 , 则类型分开计算</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">unknown</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">string</span> | <span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result1</span> = <span class="built_in">string</span> <span class="keyword">extends</span> <span class="built_in">unknown</span></span><br><span class="line">  ? <span class="built_in">string</span>[]</span><br><span class="line">  : <span class="built_in">never</span> | <span class="built_in">number</span> <span class="keyword">extends</span> <span class="built_in">unknown</span></span><br><span class="line">  ? <span class="built_in">number</span>[]</span><br><span class="line">  : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result2</span> = <span class="built_in">string</span>[] | <span class="built_in">number</span>[];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>若T为<code>never</code>，则表达式的值为<code>never</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">ToArray</span>&lt;T&gt; = T <span class="keyword">extends</span> <span class="built_in">unknown</span> ? T[] : <span class="built_in">never</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">ToArray</span>&lt;<span class="built_in">never</span>&gt;; <span class="comment">// never</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在泛型中使用 keyof</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetKeys</span>&lt;T&gt; = keyof T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">GetKeys</span>&lt;<span class="title class_">Person</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="attr">r</span>:<span class="title class_">Result</span> = <span class="string">&#x27;name&#x27;</span> <span class="comment">// name age</span></span><br></pre></td></tr></table></figure>

<ul>
<li>型约束 在泛型中使用 extends keyof</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123;<span class="attr">name</span>: <span class="built_in">string</span>, <span class="attr">age</span>: <span class="built_in">number</span>&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">GetKeyType</span>&lt;T, K <span class="keyword">extends</span> keyof T&gt; = T[K]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Result</span> = <span class="title class_">GetKeyType</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;age&#x27;</span>&gt; <span class="comment">// number 这里可以约束key</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> X = <span class="title class_">Person</span>[<span class="string">&#x27;name&#x27;</span>] <span class="comment">// string 这里不能约束key</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型进阶"><a href="#泛型进阶" class="headerlink" title="泛型进阶"></a>泛型进阶</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Person</span> = &#123; <span class="attr">id</span>: <span class="built_in">number</span>; <span class="attr">name</span>: <span class="built_in">string</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyReadonly</span>&lt;T&gt; = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> A = <span class="title class_">MyReadonly</span>&lt;<span class="title class_">Person</span>&gt;; <span class="comment">// &#123;readonly id: number, readonly name: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPartial</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]?: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> B = <span class="title class_">MyPartial</span>&lt;<span class="title class_">Person</span>&gt;; <span class="comment">// &#123;id?: number, name?: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person1</span> = &#123; id?: <span class="built_in">number</span>; name?: <span class="built_in">string</span> &#125;;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyRequired</span>&lt;T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T]-?: T[K];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> C = <span class="title class_">MyRequired</span>&lt;<span class="title class_">Person1</span>&gt;; <span class="comment">// &#123;id: number, name: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyRecord</span>&lt;K <span class="keyword">extends</span> <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">symbol</span>, V&gt; = &#123;</span><br><span class="line">  [k <span class="keyword">in</span> K]: V;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">type</span> D = <span class="title class_">MyRecord</span>&lt;<span class="built_in">string</span>, <span class="built_in">number</span>&gt;; <span class="comment">// &#123;[k: string]: number&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExclude</span>&lt;A, B&gt; = A <span class="keyword">extends</span> B ? <span class="built_in">never</span> : A;</span><br><span class="line"><span class="keyword">type</span> E = <span class="title class_">MyExclude</span>&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">1</span> | <span class="number">2</span>&gt;;  <span class="comment">// 3</span></span><br><span class="line"><span class="comment">//代入法 推导过程 前边分配后边不分配（分配定律）</span></span><br><span class="line"><span class="comment">// type E1 = (1 | 2 | 3) extends (1 | 2) ? never : (1 | 2 | 3)</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E2</span> =   (<span class="number">1</span>  <span class="keyword">extends</span> <span class="number">1</span> | <span class="number">2</span>  ? <span class="built_in">never</span> : <span class="number">1</span>)</span><br><span class="line">          | (<span class="number">2</span>  <span class="keyword">extends</span> <span class="number">1</span> | <span class="number">2</span>  ? <span class="built_in">never</span> : <span class="number">2</span>)</span><br><span class="line">          | (<span class="number">3</span>  <span class="keyword">extends</span> <span class="number">1</span> | <span class="number">2</span>  ? <span class="built_in">never</span> : <span class="number">3</span>)  <span class="comment">// 3</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">E3</span> = <span class="built_in">never</span> | <span class="built_in">never</span> | <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyExtract</span>&lt;A, B&gt; = A <span class="keyword">extends</span> B ? A : <span class="built_in">never</span>;</span><br><span class="line"><span class="keyword">type</span> F = <span class="title class_">MyExtract</span>&lt;<span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span>, <span class="number">1</span> | <span class="number">2</span>&gt; <span class="comment">// 1 | 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyOmit</span>&lt;T, <span class="title class_">Key</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> (K <span class="keyword">extends</span> <span class="title class_">Key</span> ? <span class="built_in">never</span> : K)] : T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> G = <span class="title class_">MyOmit</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>&gt; <span class="comment">// &#123;id: number&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick1</span>&lt;T, <span class="title class_">Key</span>&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> keyof T <span class="keyword">as</span> (K <span class="keyword">extends</span> <span class="title class_">Key</span> ? K : <span class="built_in">never</span>)] : T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyPick2</span>&lt;T, <span class="title class_">Key</span> <span class="keyword">extends</span> keyof T&gt; = &#123;</span><br><span class="line">  [K <span class="keyword">in</span> <span class="title class_">Key</span>] : T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H1</span> = <span class="title class_">MyPick1</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>&gt; <span class="comment">// &#123;name: string&#125;</span></span><br><span class="line"><span class="keyword">type</span> <span class="variable constant_">H2</span> = <span class="title class_">MyPick2</span>&lt;<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>&gt; <span class="comment">// &#123;name: string&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Person2</span> = &#123;</span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">name</span>: <span class="built_in">string</span></span><br><span class="line">  <span class="keyword">readonly</span> <span class="attr">id</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">MyMutable</span>&lt;T&gt; = &#123;</span><br><span class="line">  -<span class="keyword">readonly</span> [K <span class="keyword">in</span> keyof T]: T[K]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> I = <span class="title class_">MyMutable</span>&lt;<span class="title class_">Person2</span>&gt; <span class="comment">// &#123;name: string, id: number&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>windows开发环境搭建</title>
    <url>/2022/06/28/windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="包管理工具-choco"><a href="#包管理工具-choco" class="headerlink" title="包管理工具 choco"></a>包管理工具 choco</h3><p>powershell中执行 </p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> Bypass <span class="literal">-Scope</span> <span class="keyword">Process</span> <span class="literal">-Force</span>; [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol = [<span class="type">System.Net.ServicePointManager</span>]::SecurityProtocol <span class="operator">-bor</span> <span class="number">3072</span>; <span class="built_in">iex</span> ((<span class="built_in">New-Object</span> System.Net.WebClient).DownloadString(<span class="string">&#x27;[https://community.chocolatey.org/install.ps1](https://community.chocolatey.org/install.ps1)&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h3 id="用包管理工具安装make"><a href="#用包管理工具安装make" class="headerlink" title="用包管理工具安装make"></a>用包管理工具安装make</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">choco install make</span><br></pre></td></tr></table></figure>

<h3 id="notion-host"><a href="#notion-host" class="headerlink" title="notion host"></a>notion host</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="number">119.28</span>.<span class="number">13.121</span> [<span class="type">www.notion.so</span>](http://www.notion.so/)</span><br><span class="line"><span class="number">119.28</span>.<span class="number">13.121</span> [<span class="type">msgstore.www.notion.so</span>](http://msgstore.www.notion.so/)</span><br></pre></td></tr></table></figure>

<h3 id="yarn相关"><a href="#yarn相关" class="headerlink" title="yarn相关"></a>yarn相关</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 查看源</span><br><span class="line">yarn config get registry</span><br><span class="line">// 切换源</span><br><span class="line">yarn config <span class="built_in">set</span> registry http://npm.ingageapp.com:<span class="number">32100</span></span><br></pre></td></tr></table></figure>

<h3 id="npm-相关"><a href="#npm-相关" class="headerlink" title="npm 相关"></a>npm 相关</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">// 查看源</span><br><span class="line">npm config get registry</span><br><span class="line">// 切换源</span><br><span class="line">npm config <span class="built_in">set</span> registry http://registry.npmjs.org/</span><br><span class="line">npm config <span class="built_in">set</span> registry https://registry.npmmirror.com</span><br><span class="line">npm install cnpm <span class="literal">-g</span> <span class="literal">--registry</span>=https://registry.npmmirror.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>从神策小程序SDK中学习小程序数据收集</title>
    <url>/2022/02/09/%E4%BB%8E%E7%A5%9E%E7%AD%96%E5%B0%8F%E7%A8%8B%E5%BA%8FSDK%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>业务需求，需要收集用户在小程序端的特定行为（页面浏览时长，点击行为等）。</p>
<h3 id="初始实现"><a href="#初始实现" class="headerlink" title="初始实现"></a>初始实现</h3><p>刚开始是根据业务需求，在小程序端特定页面或者特定的事件上添加函数处理，重复代码多，每次修改很麻烦。</p>
<h3 id="神策的实现"><a href="#神策的实现" class="headerlink" title="神策的实现"></a>神策的实现</h3><p>在同事的帮助下看了神策收集数据的方式，将小程序特定行为数据的收集写成可配置的，大大减少了重复代码，提高了代码可维护性。</p>
<h3 id="神策SDK中的简单实现"><a href="#神策SDK中的简单实现" class="headerlink" title="神策SDK中的简单实现"></a>神策SDK中的简单实现</h3><p>小程序根据组件级别可以分为App、Page和Component。</p>
<ol>
<li>App</li>
</ol>
<p>监听App的显示和隐藏比较简单，小程序有提供专门的API</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 小程序显示</span></span><br><span class="line">wx.<span class="title function_">onAppShow</span>(<span class="keyword">function</span> (<span class="params">para</span>) &#123;</span><br><span class="line">  <span class="comment">// 获取小程序启动时的参数。与 App.onLaunch 的回调参数一致</span></span><br><span class="line">  <span class="keyword">const</span> option = wx.<span class="title function_">getLaunchOptionsSync</span>();</span><br><span class="line">  <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 小程序隐藏</span></span><br><span class="line">wx.<span class="title function_">onAppHide</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 处理逻辑</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol>
<li>Page</li>
</ol>
<p>在app.js中，App.onLaunch 中重写下Page，以记录进入每个页面的浏览时长为例：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> pageEnterTime;</span><br><span class="line"><span class="title class_">App</span>(&#123;</span><br><span class="line">  <span class="attr">onLaunch</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> oldPage = <span class="title class_">Page</span></span><br><span class="line">    <span class="title class_">Page</span> = <span class="keyword">function</span> (<span class="params">obj</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> oldOnLoad = obj.<span class="property">onLoad</span></span><br><span class="line">      <span class="comment">// 进入页面</span></span><br><span class="line">      obj.<span class="property">onLoad</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        pageEnterTime = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">        oldOnLoad &amp;&amp; oldOnLoad.<span class="title function_">call</span>(<span class="variable language_">this</span>, options);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> oldOnHide = obj.<span class="property">onHide</span></span><br><span class="line">      <span class="comment">// 页面跳转</span></span><br><span class="line">      obj.<span class="property">onHide</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        pageStayTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() - pageEnterTime;</span><br><span class="line">        <span class="comment">// 记录时间</span></span><br><span class="line">        oldOnHide &amp;&amp; oldOnHide.<span class="title function_">call</span>(<span class="variable language_">this</span>, options);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">const</span> oldOnUnload = obj.<span class="property">onUnload</span></span><br><span class="line">      <span class="comment">// 返回按钮</span></span><br><span class="line">      obj.<span class="property">onUnload</span> = <span class="keyword">function</span> (<span class="params">options</span>) &#123;</span><br><span class="line">        pageStayTime = <span class="title class_">Date</span>.<span class="title function_">now</span>() - pageEnterTime</span><br><span class="line">        <span class="comment">// 记录时间</span></span><br><span class="line">        oldOnUnload &amp;&amp; oldOnUnload.<span class="title function_">call</span>(<span class="variable language_">this</span>, options);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="title function_">oldPage</span>(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>其他的点击事件或者页面事件类似，都可以写成这种可配置的方式</p>
<ol>
<li>Component</li>
</ol>
<p>Component和Page类似，在App.onLaunch 中重写下Component，然后处理Component事件或者点击事件</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/sensorsdata/sa-sdk-miniprogram/blob/master/product/sensorsdata.full.js">sa-sdk-miniprogram</a></p>
]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>初始化一个ts-jest项目</title>
    <url>/2022/07/26/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAts-jest%E9%A1%B9%E7%9B%AE/</url>
    <content><![CDATA[<h3 id="全局安装typescript"><a href="#全局安装typescript" class="headerlink" title="全局安装typescript"></a>全局安装typescript</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>

<h3 id="初始化typescript配置"><a href="#初始化typescript配置" class="headerlink" title="初始化typescript配置"></a>初始化typescript配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure>

<h3 id="配置类型声明和构建后目录"><a href="#配置类型声明和构建后目录" class="headerlink" title="配置类型声明和构建后目录"></a>配置类型声明和构建后目录</h3><figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// tsconfig.json</span></span><br><span class="line"><span class="string">&quot;types&quot;</span>: [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;jest&quot;</span>],</span><br><span class="line"><span class="string">&quot;outDir&quot;</span>: <span class="string">&quot;./dist&quot;</span>,</span><br></pre></td></tr></table></figure>

<h3 id="添加jest和ts-node等依赖"><a href="#添加jest和ts-node等依赖" class="headerlink" title="添加jest和ts-node等依赖"></a>添加jest和ts-node等依赖</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i -D jest typescript</span><br><span class="line">npm i -D ts-jest @types/jest</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Creating config</span></span><br><span class="line">npx ts-jest config:init</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">run <span class="built_in">test</span></span></span><br><span class="line">npx jest</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>在 Windows Git Bash 中安装 Zsh</title>
    <url>/2022/01/18/%E5%9C%A8%20Windows%20Git%20Bash%E4%B8%AD%E5%AE%89%E8%A3%85Zsh/</url>
    <content><![CDATA[<h3 id="在-Git-Bash-中安装-Zsh"><a href="#在-Git-Bash-中安装-Zsh" class="headerlink" title="在 Git Bash 中安装 Zsh"></a>在 Git Bash 中安装 Zsh</h3><ol>
<li>从 MSYS2 软件包存储库 下载最新的<a href="https://packages.msys2.org/package/zsh?repo=msys&variant=x86_64">MSYS2</a>zsh 软件包。该文件将被命名为 类似于 .<code>zsh-5.8-5-x86_64.pkg.tar.zst</code></li>
<li>解压下载文件到 Git Bash 安装目录中 <code>C:\Program Files\Git</code></li>
<li>打开 Git Bash 并运行</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zsh</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>重要说明：</strong>在 Zsh 首次使用向导中配置选项卡完成和历史记录。如果由于某种原因它没有出现，或者您跳过了它，请重新运行它：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">autoload</span> -U zsh-newuser-install</span><br><span class="line">zsh-newuser-install -f</span><br></pre></td></tr></table></figure>

<ul>
<li>若要配置历史记录，请按 ，根据需要按 更改值，然后按 。<code>11-30</code></li>
<li>要配置完成，请按”使用新的完成系统”，然后按 。<code>20</code></li>
<li>按以保存设置。<code>0</code></li>
</ul>
<p>会出现一行报错：<code>ERROR: this script is obsolete, please see git-completion.zsh</code>删除文件 <code>/etc/profile.d/git-prompt.sh</code> 即可</p>
<ol>
<li>通过将以下内容附加到您的文件，将 Zsh 配置为默认 shell：<code>~/.bashrc</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -t 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">exec</span> zsh</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h3 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh-my-zsh"></a>安装 oh-my-zsh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="安装插件和主题"><a href="#安装插件和主题" class="headerlink" title="安装插件和主题"></a>安装插件和主题</h3><ol>
<li>修改插件</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-syntax-highlighting zsh-autosuggestions)</span><br></pre></td></tr></table></figure>

<ol>
<li>安装<code>zsh-syntax-highlighting</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>

<ol>
<li>安装<code>zsh-autosuggestions</code></li>
</ol>
<ul>
<li><p>注意：终端中可能会出现奇怪的伪影和间距。要解决此问题，请使用版本：<code>v0.7.0v.0.6.4</code></p>
<p>  <code>cd ~/.oh-my-zsh/plugins/zsh-autosuggestions   git checkout tags/v0.6.4 -b v0.6.4-branch</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions ~/.oh-my-zsh/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://dominikrys.com/posts/zsh-in-git-bash-on-windows/">Installing Zsh (and oh-my-zsh) in Windows Git Bash</a></li>
<li><a href="https://amagi.yukisaki.io/article/96e5adc4-1212-4260-8399-4dfd3964dc3b/">Git-Zsh on Windows安装与配置</a></li>
<li><a href="https://juejin.cn/post/7023578642156355592">oh-my-zsh 国内安装及配置</a></li>
</ol>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>环境配置</tag>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>前端音频录制和播放方案</title>
    <url>/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h2 id="前端音频录制和播放方案"><a href="#前端音频录制和播放方案" class="headerlink" title="前端音频录制和播放方案"></a>前端音频录制和播放方案</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>业务需要，前端需要进行音频的录制和播放。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="音频录制"><a href="#音频录制" class="headerlink" title="音频录制"></a>音频录制</h4><p><a href="https://recordrtc.org/">recordrtc</a> 是一个成熟的前端音视频桌面录制库，可以选用这个库来处理，可以每隔几秒上传下录制的内容</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stream = <span class="keyword">await</span> navigator.<span class="property">mediaDevices</span>.<span class="title function_">getUserMedia</span>(&#123;<span class="attr">audio</span>: <span class="literal">true</span>&#125;); <span class="comment">// 获取权限</span></span><br><span class="line"><span class="keyword">let</span> recorder = <span class="keyword">new</span> <span class="title class_">RecordRTCPromisesHandler</span>(stream, &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;audio&#x27;</span>,</span><br><span class="line">    <span class="attr">timeSlice</span>: <span class="number">1000</span>, <span class="comment">// 时间切片</span></span><br><span class="line">    <span class="attr">ondataavailable</span>: <span class="function">(<span class="params">data</span>) =&gt;</span> &#123; <span class="comment">// 时间切片回调</span></span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">recorder.<span class="title function_">startRecording</span>(); <span class="comment">// 开始录制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">sleep</span> = m =&gt; <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">setTimeout</span>(r, m));</span><br><span class="line"><span class="keyword">await</span> <span class="title function_">sleep</span>(<span class="number">3000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> recorder.<span class="title function_">stopRecording</span>();  <span class="comment">// 暂停录制</span></span><br><span class="line"><span class="keyword">let</span> blob = <span class="keyword">await</span> recorder.<span class="title function_">getBlob</span>();</span><br><span class="line"><span class="title function_">invokeSaveAsDialog</span>(blob);  <span class="comment">// 保存完整文件</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h4><p>录制的音频格式可以使用原生的<code>audio</code>标签进行播放，考虑到美观性，可以使用一些三方件来做处理。</p>
<ol>
<li><code>ios</code>音频样式 <a href="https://howlerjs.com/">howler</a><img src="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/01.png" class="lazy" data-srcset="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">
<img src="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/02.png" class="lazy" data-srcset="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/02.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class=""></li>
<li>波形可视化 <a href="https://wavesurfer-js.org/">wavesurfer</a><img src="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/03.png" class="lazy" data-srcset="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/03.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">  </li>
<li>通用的样式 <a href="https://www.npmjs.com/package/react-h5-audio-player">react-h5-audio-player</a><img src="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/04.png" class="lazy" data-srcset="/2023/03/14/%E5%89%8D%E7%AB%AF%E9%9F%B3%E9%A2%91%E5%BD%95%E5%88%B6%E5%92%8C%E6%92%AD%E6%94%BE%E6%96%B9%E6%A1%88/04.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class=""></li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://recordrtc.org/">recordrtc</a></li>
<li><a href="https://howlerjs.com/">howler</a></li>
<li><a href="https://wavesurfer-js.org/">wavesurfer</a></li>
<li><a href="https://www.npmjs.com/package/react-h5-audio-player">react-h5-audio-player</a></li>
</ol>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>音频</tag>
      </tags>
  </entry>
  <entry>
    <title>存储引擎-简介</title>
    <url>/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="数据存储与检索背景"><a href="#数据存储与检索背景" class="headerlink" title="数据存储与检索背景"></a>数据存储与检索背景</h2><p>数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>OLTP(online transaction processing)</th>
<th>OLAP(online analysis processing)</th>
</tr>
</thead>
<tbody><tr>
<td>系统功能</td>
<td>日常交易处理&#x2F;在线失误处理</td>
<td>统计、分析、报表&#x2F;在线分析处理</td>
</tr>
<tr>
<td>设计目标</td>
<td>面向实时交易类应用</td>
<td>面向统计分析类应用</td>
</tr>
<tr>
<td>数据处理</td>
<td>当前的、最新的</td>
<td>历史的、聚集的</td>
</tr>
<tr>
<td>实时性</td>
<td>实时性读写要求高</td>
<td>实时性读写要求低</td>
</tr>
<tr>
<td>事务</td>
<td>强事务</td>
<td>弱事务</td>
</tr>
<tr>
<td>分析要求</td>
<td>低、简单</td>
<td>高、复杂</td>
</tr>
</tbody></table>
<h2 id="OLTP"><a href="#OLTP" class="headerlink" title="OLTP"></a>OLTP</h2><p>大多数OLTP系统中，数据存储都是以面向行(row-oriented)的方式组织的。这种方式把一行数据存放在一起。在OLAP系统中，查询语句一般是获取大量行数据中的特定某几列。</p>
<p>OLTP的存储引擎分为<strong>面向页（b+tree）存储引擎</strong>和<strong>日志结构（lsm tree）存储引擎</strong></p>
<h2 id="数据文件和索引文件"><a href="#数据文件和索引文件" class="headerlink" title="数据文件和索引文件"></a><strong><strong>数据文件和索引文件</strong></strong></h2><p>数据库系统的主要目的是存储数据和快速检索数据。为了实现快速检索数据会以特殊的格式来保存到文件中。特殊的存储格式可以确保：</p>
<ul>
<li>存储效率最高：存储每条数据记录的额外开销最小。</li>
<li>访问效率最高：数据记录能够以最少的步骤被访问。</li>
<li>更新效率最高：对磁盘数据做最少改动就能完成记录更新。</li>
</ul>
<p>数据库系统的表中存储了由多个字段构成的数据记录，每个表保存在一个单独的文件中。表中的每一条记录可以通过搜索键查找到，为了能快速从文件中查找到对应记录，数据库系统使用索引。索引实际上是一种特殊的数据结构，它可以帮助在数据文件中快速定位数据记录，而且不需要扫描整个数据文件中的所有数据记录。通常索引会在一个或一组能够能识别数据记录的字段上构建。</p>
<p>通常数据库系统的数据记录和索引是分别存储到不同文件中的：数据文件存储数据记录；而索引文件索引数据。索引文件通常比数据文件小，通过索引文件中的数据就可以快速定位数据文件中记录位置。</p>
<h2 id="数据文件"><a href="#数据文件" class="headerlink" title="数据文件"></a><strong>数据文件</strong></h2><p>数据文件（有时称为主文件（primary file））通常可以用<strong>索引组织表</strong>（Index-Organized Table，IOT）、<strong>堆组织表</strong>（heap-organized table，即堆文件）或<strong>哈希组织表</strong>（hash-organized table，即哈希文件）来实现。</p>
<ul>
<li>堆组织表(heap-organized tables)，记录不需要遵循任何特定的顺序，并且大多数情况下它们都是按写顺序放置的。这样，在追加新的页时，数据库便不需要额外的工作或文件重组。堆文件需要额外的索引结构来指向存储数据记录的位置，以使其能够被检索到。(Oracle, PostgreSQL)</li>
<li>哈希组织表（hash-organized tables），记录存储在桶中，并且键的哈希值确定记录属于哪个桶。存储在桶中的记录可以按追加顺序存储，也可以按键排序存储以提高查找速度。</li>
<li>索引组织表(Index-Organized Table) 将索引和数据记录存储在一起。由于记录是按键的顺序存储的，所以索引组织表中的范围扫描可以通过顺序扫描其内容来实现。(innoDB)</li>
</ul>
<img src="/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/Untitled.png" class="lazy" data-srcset="/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/Untitled.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="Untitled">

<h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a><strong><strong>索引文件</strong></strong></h2><p>索引是一种能帮助高效磁盘数据检索的数据结构。通常索引具有特殊的数据结构，该结构能映射键到键对应数据记录在数据文件中的位置。</p>
<p>主文件(数据文件)上的索引称为主索引。在大多数情况下，主索引构建在主键上，主键可以是一个键也可以是一组能标识记录的键。所有其他索引都称为辅助索引（Secondary indexes）。</p>
<p>辅助索引可以直接映射到数据记录位置，或者只是简单的映射到记录所对应的主键。多个辅助索引可以指向相同的记录，从而允许通过不同的字段和不同的索引来查找单个数据记录。主索引文件为每个搜索键保存唯一一个条目，而次索引可能为每个搜索键保存多个条目。</p>
<p>如果数据记录的顺序和搜索键的顺序一致，则此索引称为聚簇索引。这种情况下索引和的数据记录通常存储在相同的文件中。如果数据存储在单独的文件中，并且其顺序和键的顺序不一致，则该索引称非聚簇索引。</p>
<img src="/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/Untitled.png" class="lazy" data-srcset="/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/Untitled.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="Untitled">

<p>许多数据库系统都有自带显式主键对应唯一一条数据库记录。在没有指定主键的情况下，存储引擎可以创建一个隐式主键(如，MySQL InnoDB会添加一个自动递增列)。</p>
<h2 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h2><ol>
<li>直接通过文件偏移量引用数据记录</li>
<li>通过主键索引引用数据记录</li>
</ol>
<p>通过直接引用数据，我们可以减少查找磁盘的次数，但在维护过程中，每当更新或重新定位记录时，我们都必须承担更新指针所带来的成本。通过主索引间接引用数据可以降低指针更新的成本，但在读取路径上成本更高。</p>
<p>为了减少指针更新的成本，一些数据库的具体实现是使用主键进行间接操作，而不是直接使用数据偏移量。例如，MySQL InnoDB使用主索引并执行两次查找：一次在二级索引中，一次在主索引中。这样并不直接使用二级索引查询得到的偏移量，因此增加了一次主索引的查询开销。</p>


<h2 id="存储结构的分类"><a href="#存储结构的分类" class="headerlink" title="存储结构的分类"></a>存储结构的分类</h2><ol>
<li>In-place update structure: 就地更新结构，如B树、B+树，直接覆盖旧记录来存储更新内容。</li>
<li>Out-of-place update structure：异位更新结构，如LSM树，会将更新的内容存储到新的位置，不覆盖旧的条目。</li>
</ol>
<h3 id="就地更新结构"><a href="#就地更新结构" class="headerlink" title="就地更新结构"></a>就地更新结构</h3><p>B树，B+树等，只会存储每个记录的最新版本，一般读性能优，写入代价比较大，因为更新会导致随机IO；在早期机械硬盘结构上表现最好，所以占据了主流。</p>
<h3 id="异位更新结构"><a href="#异位更新结构" class="headerlink" title="异位更新结构"></a>异位更新结构</h3><p>LSM树，顺序写，写入性能更优，读取性能不太好。</p>
<p>SSD 上有两个显著的优势，第一个是 SSD 没有寻到时间，相比机械硬盘读性能有了很大的提升，很大程度上弥补了 lsm 数读取性能弱这一短板。第二点，SSD是基于闪存进行存储的，但闪存不能覆盖写，闪存块需要擦除才能够写入。而 lsm 数而 lsm 数追加写的写入模式天然契合了 SSD 的这种特性，从而很大程度上节省了擦除的损耗，并提升了 SSD 的使用寿命。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>存储</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>存储</tag>
      </tags>
  </entry>
  <entry>
    <title>最简单的K-V数据库后端实现（数据库的简单实现1）</title>
    <url>/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E7%AE%80%E5%8D%95%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%931/</url>
    <content><![CDATA[<p>这里将用TypeScript开始实现一个最简单的 Key-Value 数据库，以理解数据库是怎么工作的。</p>
<h3 id="建立-REPL-环境"><a href="#建立-REPL-环境" class="headerlink" title="建立 REPL 环境"></a>建立 REPL 环境</h3><p>首先要建立建立 REPL 环境，这样就可以在终端输入语句，然后查看输出，并不断进行这个循环直到停止使用。</p>
<p>Node.js 的标准库本身提供了一个叫 <code>repl</code>的模块，只需要几行代码，就可以非常迅速的建立起一个 REPL 环境。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">repl.<span class="title function_">start</span>(&#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;db.js &gt;&gt; &#x27;</span>,</span><br><span class="line">  <span class="attr">eval</span>: <span class="function">(<span class="params">evalCmd</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="string">`Unrecognized command <span class="subst">$&#123;evalCmd&#125;</span>`</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>使用 <code>ts-node</code>这样的工具来直接运行这个文件，就可以跑起来了。为了测试，试试输入 <code>test</code>并回车，可以看到下面这样的输出：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">db.<span class="property">js</span> &gt;&gt; test</span><br><span class="line"><span class="title class_">Unrecognized</span> command <span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="最简单的实现"><a href="#最简单的实现" class="headerlink" title="最简单的实现"></a>最简单的实现</h3><p>实现一个将数据存储到硬盘上的数据库，这样即使进程退出数据也不会丢失。</p>
<p>实现思路：直接把数据序列化以后作为文本塞到文件的最后，同时把键和值用逗号分割。每当读取数据时，扫描这个文件来一行一行遍历查询键名。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">&#x27;readline&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbFile = <span class="string">&#x27;./data.db&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">key: string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> readable = fs.<span class="title function_">createReadStream</span>(dbFile);</span><br><span class="line">  <span class="keyword">const</span> reader = readline.<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: readable &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;string&gt;(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">value</span>: any;</span><br><span class="line">    reader.<span class="title function_">on</span>(<span class="string">&#x27;line&#x27;</span>, <span class="function"><span class="params">line</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> [k, v] = line.<span class="title function_">split</span>(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">      <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    readable.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reader.<span class="title function_">close</span>();</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">key: string, value: any</span>) =&gt; &#123;</span><br><span class="line">  fs.<span class="title function_">appendFileSync</span>(dbFile, <span class="string">`<span class="subst">$&#123;key&#125;</span>,<span class="subst">$&#123;value&#125;</span>\n`</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后简单的修改一下 <code>eval</code> 参数以接入 <code>set</code> 和 <code>get</code> 接口，可以先不管解析 SQL 语句之类的事情，使用一个最简单的语法，</p>
<ul>
<li><code>set [key] [value]</code></li>
<li><code>get [key]</code></li>
</ul>
<p>语法的解析也是暂时假定所有的输入都是正确的格式，这样可以用非常简单的方式来实现：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> replServer = repl.<span class="title function_">start</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">eval</span>: <span class="keyword">async</span> (evalCmd, _, __, callback) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> cmd = evalCmd.<span class="title function_">trim</span>();</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key, value] = cmd.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">set</span>(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key] = cmd.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">await</span> <span class="title function_">get</span>(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="string">`Unrecognized command <span class="subst">$&#123;evalCmd&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>启动以后测试一下，可以看到已经成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">db.js &gt;&gt; set a aaa</span><br><span class="line">&#x27;aaa&#x27;</span><br><span class="line">db.js &gt;&gt; set b bbb</span><br><span class="line">&#x27;bbb&#x27;</span><br><span class="line">db.js &gt;&gt; get a</span><br><span class="line">&#x27;aaa&#x27;</span><br><span class="line">db.js &gt;&gt; set a ccc</span><br><span class="line">&#x27;ccc&#x27;</span><br><span class="line">db.js &gt;&gt; get a</span><br><span class="line">&#x27;ccc&#x27;</span><br></pre></td></tr></table></figure>

<p><code>set</code> 函数在简单的场景性能其实非常好，因为在文件尾部追加写入其实是很高效的，像很多日志的实现，都是一个 <strong>append-only</strong> 的文件，虽然还有像并发，容错等很多额外的事情要处理，但核心原理是一样的。</p>
<p>但对于读取数据的 <code>get</code> 操作，它的性能则非常糟糕，因为每次必须从头到尾扫描整个文件来进行查找。从算法的角度来说，它的复杂度是 <strong>O(N)</strong> 。也就是说随着数据量的增大，查找的时间也会线性增长。要解决这个问题，需要引入一个叫 <strong>索引</strong> 的额外结构，比如查汉语字典时，可以根据偏旁部首或者拼音，在目录中找到他们的大概位置，直接翻到那一页再仔细一条条查找，索引的概念和目录就是一样的。</p>
<p>同时还有一个问题，在存储时将所有的值序列化为字符串再作为文本直接写入到文件中，同时使用逗号分隔键和值，这个叫 <strong>CSV (comma-separated values)</strong> 格式，写入时会默认使用 UTF-8 的编码格式，每一个 UTF-8 字符会使用 1-4 个字节来存储，但对某些值来说，将其转化成字符串有可能会增大它的体积，例如布尔值完全可以用一个 bit 位来代替，而转变成了字符串 “true” 在 UTF-8 中则变成了 4 个字节。</p>
<p>使用文本格式的最大优点，是提供给了人类一个很好的可读性，事实上 MySQL 确实就有一个<a href="https://dev.mysql.com/doc/refman/5.7/en/csv-storage-engine.html">CSV 存储引擎</a>。但在绝大多数情况下，文本格式并不是一个最佳选择，毕竟提供给人类可读性并不是一个很高优的目标，而使用二进制格式能有更好的性能表现。</p>
<p>虽然用 Node.js 来实现肯定不会有太好的性能，但这个学习过程中会像设计一个真正的数据库一样去思考。在 Node 中可以利用 <code>[Buffer](https://nodejs.org/api/buffer.html#buffer)</code> 来实现对二进制数据进行操作，因此后续会将文本格式改为二进制格式。</p>
<p>最后附上完整的代码：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> repl <span class="keyword">from</span> <span class="string">&quot;repl&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&quot;fs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> readline <span class="keyword">from</span> <span class="string">&quot;readline&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbFile = <span class="string">&quot;./data.db&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 从 db文件中遍历所有行找数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">key: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> readable = fs.<span class="title function_">createReadStream</span>(dbFile);</span><br><span class="line">  <span class="keyword">const</span> reader = readline.<span class="title function_">createInterface</span>(&#123; <span class="attr">input</span>: readable &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>&lt;<span class="built_in">string</span>&gt;(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="attr">value</span>: <span class="built_in">string</span>;</span><br><span class="line">    reader.<span class="title function_">on</span>(<span class="string">&quot;line&quot;</span>, <span class="function">(<span class="params">line: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> [k, v] = line.<span class="title function_">split</span>(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (k === key) &#123;</span><br><span class="line">        value = v;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    readable.<span class="title function_">on</span>(<span class="string">&quot;end&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      reader.<span class="title function_">close</span>();</span><br><span class="line">      <span class="title function_">resolve</span>(value);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 写数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  fs.<span class="title function_">appendFileSync</span>(dbFile, <span class="string">`<span class="subst">$&#123;key&#125;</span>,<span class="subst">$&#123;value&#125;</span>\n`</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 检查DB文件是否存在，不存在则创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">filePath</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">checkFiles</span> = (<span class="params">filePath: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> p = path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), filePath);</span><br><span class="line">  <span class="keyword">const</span> exist = fs.<span class="title function_">existsSync</span>(p);</span><br><span class="line">  <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(p, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">repl.<span class="title function_">start</span>(&#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&quot;db.js &gt;&gt; &quot;</span>,</span><br><span class="line">  <span class="attr">eval</span>: <span class="keyword">async</span> (evalCmd, _context, _file, callback) =&gt; &#123;</span><br><span class="line">    <span class="title function_">checkFiles</span>(dbFile);</span><br><span class="line">    <span class="keyword">const</span> cmd = evalCmd.<span class="title function_">trim</span>();</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&quot;set&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key, value] = cmd.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="title function_">set</span>(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&quot;get&quot;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key] = cmd.<span class="title function_">split</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line">      <span class="keyword">const</span> value = <span class="keyword">await</span> <span class="title function_">get</span>(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="string">`Unrecognized command <span class="subst">$&#123;evalCmd&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://db-js.vercel.app/2">Build a simple database with Node.js (db-js.vercel.app)</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库的简单实现</tag>
      </tags>
  </entry>
  <entry>
    <title>添加索引和二进制格式存储（数据库的简单实现2）</title>
    <url>/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A82/</url>
    <content><![CDATA[<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><p>索引是从主数据衍生出来的额外结构，添加和删除索引完全不会影响数据，只会影响查询的性能。维护这个结构会产生一些开销，因为需要在写入的时候多做一点操作，去更新索引，这样才能在读取的时候利用索引来加快一点速度。任何类型的索引通常都会减慢写入速度，因此数据库默认并不会索引所有的内容，而是需要用户来根据自己的情况做出取舍来手动选择索引，尽量选择那些带来较大收益而且又不会引入超出必要开销的索引。</p>
<h3 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h3><p>之前实现的简单数据库，可以使用<code>Map</code>来索引文件中的数据，假设依然是追加写入的文件，和之前一样，可以设计一个最简单的索引策略：保留一个内存中的散列映射，其中每个键都映射到数据文件中的一个字节偏移量，指明了可以找到对应值的位置。</p>
<h3 id="为数据库加上索引并把存储格式改为二进制"><a href="#为数据库加上索引并把存储格式改为二进制" class="headerlink" title="为数据库加上索引并把存储格式改为二进制"></a>为数据库加上索引并把存储格式改为二进制</h3><p>接下来开始实现一个最简单的保存在内存中的哈希索引，这在 Node 环境中非常简单，只需要用一个 <code>Map</code>就可以。数据存储为二进制后，可以将数据看成一个大的数组，读取数据只需要知道数据的下标和数据的大小就可以:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="title class_">Offset</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Size</span> = <span class="built_in">number</span>; <span class="comment">// how many bytes</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Index</span> = [<span class="title class_">Offset</span>, <span class="title class_">Size</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Index</span>&gt;();</span><br></pre></td></tr></table></figure>

<p>对于不同的数据类型，需要针对性的将其转换为二进制，简单起见，暂时只支持三种数据类型，分别是数字、布尔值和字符串:</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">DataType</span> &#123;  <span class="title class_">Boolean</span>,  <span class="title class_">Number</span>,  <span class="title class_">String</span>,&#125;</span><br></pre></td></tr></table></figure>

<p>针对这三个类型编写一个序列化的函数，同时，为了在读取时针对性的进行反序列化，我们还需要将它的类型信息也存进去，规则是下面这样的：</p>
<ul>
<li>每一个数据都用第一个字节来存储它的类型信息，0，1，2 分别对应布尔值，数字和字符串；</li>
<li>布尔值，用一个字节来表示（主要是 Node 最少得分配一个字节），1 为 true，0 为 false；</li>
<li>数字，因为 Node 中的普通数字实际上都是双精度浮点数，我们就将其都作为 double 处理，占用 8 个字节（64 位），对于可能溢出的大数字先不管；</li>
<li>除了布尔和数字，其他都当做字符串处理，采用 UTF-8 编码。</li>
</ul>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> serialize = (<span class="attr">val</span>: <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">Buffer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">buf</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">type</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">data</span>: <span class="title class_">Buffer</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> val) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">Boolean</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, val ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">Number</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">8</span>);</span><br><span class="line">      data.<span class="title function_">writeDoubleBE</span>(val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">String</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">String</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="keyword">type</span>, data]);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意数字的部分用到了 <code>buffer.writeDoubleBE</code>，<code>BE</code>的意思是 <strong>Big-Endian</strong>，中文叫大端序，还有一种叫小端序，对于<a href="https://en.wikipedia.org/wiki/Endianness">字节序</a>这里不赘述。具体使用什么样的字节序没什么讲究，重要的是在序列化和反序列化的时候一定要使用相同的字节序，这里我们默认全部使用大端序。</p>
<p>反序列化也很简单：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> deserialize = (<span class="attr">buf</span>: <span class="title class_">Buffer</span>): boolean | number | <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> type = buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">Boolean</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf[<span class="number">1</span>] === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">Number</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">readDoubleBE</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">String</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>整体的思路就确定了：</p>
<ul>
<li>启动时先获取数据库文件 fd，开启 repl 环境；</li>
<li>对于 set 命令把 key&#x2F;value 交给 <code>set</code> 函数，进行序列化，先更新索引，再写入文件；</li>
<li>对于 get 命令解析出 key，交给 <code>get</code> 函数，先从索引中查找，如果有的话根据偏移位置和数据大小，然后直接读取出来并进行反序列化然后返回。</li>
</ul>
<p>可以重构一下之前的 <code>get</code>和 <code>set</code>函数：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">key: string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> index = map.<span class="title function_">get</span>(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (index) &#123;</span><br><span class="line">    <span class="keyword">const</span> [offset, size] = index;</span><br><span class="line">    <span class="keyword">const</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(size);</span><br><span class="line">    fs.<span class="title function_">readSync</span>(fd, buffer, <span class="number">0</span>, size, offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">deserialize</span>(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">key: string, value: string</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">buffer</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">&#x27;true&#x27;</span> || value === <span class="string">&#x27;false&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// boolean</span></span><br><span class="line">    buffer = <span class="title function_">serialize</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^-?\d+$/</span>.<span class="title function_">test</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// number</span></span><br><span class="line">    buffer = <span class="title function_">serialize</span>(<span class="built_in">parseFloat</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer = <span class="title function_">serialize</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> size = buffer.<span class="property">byteLength</span>;</span><br><span class="line">  <span class="keyword">const</span> offset = fs.<span class="title function_">statSync</span>(dbFile).<span class="property">size</span>;</span><br><span class="line">  map.<span class="title function_">set</span>(key, [offset, size]);</span><br><span class="line">  fs.<span class="title function_">appendFileSync</span>(dbFile, buffer);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用 <code>ts-node main.ts</code>来直接启动并进行测试。</p>
<p>最后附上完整的代码：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> repl <span class="keyword">from</span> <span class="string">&#x27;repl&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbFile = <span class="string">&#x27;./data.db&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Offset</span> = <span class="built_in">number</span>;</span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Size</span> = <span class="built_in">number</span>; <span class="comment">// how many bytes</span></span><br><span class="line"><span class="keyword">type</span> <span class="title class_">Index</span> = [<span class="title class_">Offset</span>, <span class="title class_">Size</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="title class_">Map</span>&lt;<span class="built_in">string</span>, <span class="title class_">Index</span>&gt;();</span><br><span class="line"><span class="keyword">const</span> fd = fs.<span class="title function_">openSync</span>(dbFile, <span class="string">&#x27;a+&#x27;</span>); <span class="comment">// `a+` flag means open file for reading and appending.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> <span class="title class_">DataType</span> &#123;</span><br><span class="line">  <span class="title class_">Boolean</span>,</span><br><span class="line">  <span class="title class_">Number</span>,</span><br><span class="line">  <span class="title class_">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 从 db文件中遍历所有行找数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">key: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> index = map.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (index) &#123;</span><br><span class="line">    <span class="keyword">const</span> [offset, size] = index;</span><br><span class="line">    <span class="keyword">const</span> buffer = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(size);</span><br><span class="line">    fs.<span class="title function_">readSync</span>(fd, buffer, <span class="number">0</span>, size, offset);</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">deserialize</span>(buffer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 写数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">key</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">set</span> = (<span class="params">key: <span class="built_in">string</span>, value: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">buffer</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">if</span> (value === <span class="string">&#x27;true&#x27;</span> || value === <span class="string">&#x27;false&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// boolean</span></span><br><span class="line">    buffer = <span class="title function_">serialize</span>(<span class="title class_">JSON</span>.<span class="title function_">parse</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/^-?\d+$/</span>.<span class="title function_">test</span>(value)) &#123;</span><br><span class="line">    <span class="comment">// number</span></span><br><span class="line">    buffer = <span class="title function_">serialize</span>(<span class="built_in">parseFloat</span>(value));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    buffer = <span class="title function_">serialize</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> size = buffer.<span class="property">byteLength</span>;</span><br><span class="line">  <span class="keyword">const</span> offset = fs.<span class="title function_">statSync</span>(dbFile).<span class="property">size</span>;</span><br><span class="line">  map.<span class="title function_">set</span>(key, [offset, size]);</span><br><span class="line">  fs.<span class="title function_">appendFileSync</span>(dbFile, buffer);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 反序列化函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> deserialize = (<span class="attr">buf</span>: <span class="title class_">Buffer</span>): <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">type</span> = buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">Boolean</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf[<span class="number">1</span>] === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">Number</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">readDoubleBE</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="title class_">DataType</span>.<span class="property">String</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toString</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> buf.<span class="title function_">slice</span>(<span class="number">1</span>).<span class="title function_">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 序列化函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; <span class="variable">val</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> serialize = (<span class="attr">val</span>: <span class="built_in">boolean</span> | <span class="built_in">number</span> | <span class="built_in">string</span>): <span class="function"><span class="params">Buffer</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">buf</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">type</span>: <span class="title class_">Buffer</span>;</span><br><span class="line">  <span class="keyword">let</span> <span class="attr">data</span>: <span class="title class_">Buffer</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (<span class="keyword">typeof</span> val) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;boolean&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">Boolean</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, val ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;number&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">Number</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">allocUnsafe</span>(<span class="number">8</span>);</span><br><span class="line">      data.<span class="title function_">writeDoubleBE</span>(val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;string&#x27;</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">String</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(val);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>: &#123;</span><br><span class="line">      <span class="keyword">type</span> = <span class="title class_">Buffer</span>.<span class="title function_">alloc</span>(<span class="number">1</span>, <span class="title class_">DataType</span>.<span class="property">String</span>);</span><br><span class="line">      data = <span class="title class_">Buffer</span>.<span class="title function_">from</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buf = <span class="title class_">Buffer</span>.<span class="title function_">concat</span>([<span class="keyword">type</span>, data]);</span><br><span class="line">  <span class="keyword">return</span> buf;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 检查DB文件是否存在，不存在则创建</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">string</span>&#125; <span class="variable">filePath</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">*</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">checkFiles</span> = (<span class="params">filePath: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> p = path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), filePath);</span><br><span class="line">  <span class="keyword">const</span> exist = fs.<span class="title function_">existsSync</span>(p);</span><br><span class="line">  <span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">    fs.<span class="title function_">writeFileSync</span>(p, <span class="string">&quot;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">repl.<span class="title function_">start</span>(&#123;</span><br><span class="line">  <span class="attr">prompt</span>: <span class="string">&#x27;db.js &gt;&gt; &#x27;</span>,</span><br><span class="line">  <span class="attr">eval</span>: <span class="keyword">async</span> (evalCmd, _context, _file, callback) =&gt; &#123;</span><br><span class="line">    <span class="title function_">checkFiles</span>(dbFile);</span><br><span class="line">    <span class="keyword">const</span> cmd = evalCmd.<span class="title function_">trim</span>();</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&#x27;set&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key, value] = cmd.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="title function_">set</span>(key, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cmd.<span class="title function_">startsWith</span>(<span class="string">&#x27;get&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">const</span> [, key] = cmd.<span class="title function_">split</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">      <span class="keyword">const</span> value = <span class="title function_">get</span>(key);</span><br><span class="line">      <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">callback</span>(<span class="literal">null</span>, <span class="string">`Unrecognized command <span class="subst">$&#123;evalCmd&#125;</span>`</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://db-js.vercel.app/4">Build a simple database with Node.js (db-js.vercel.app)</a></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>数据库的简单实现2</tag>
      </tags>
  </entry>
  <entry>
    <title>站在React的角度理解React</title>
    <url>/2022/05/17/%E7%AB%99%E5%9C%A8React%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3React/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文基于<a href="https://www.tangdingblog.cn/blog/react/buildyourownreact-2020-09-22/#renderandcommit">建造属于你的react</a>  这篇文章整理出来React的简单实现过程和一些核心概念，具体的细节和实现过程请参考原文。</p>
<p>React渲染过程中有两个重要的对象 <code>ReactElement</code> 对象和 <code>fiber</code> 对象</p>
<ol>
<li><code>ReactElement</code> 对象</li>
</ol>
<p>所有采用<code>jsx</code>语法书写的节点, 都会被编译器转换, 最终会以<code>React.createElement(...)</code>的方式, 创建出来一个与之对应的<code>ReactElement</code>对象。</p>
<p><code>ReactElement</code>对象可以理解为<code>jsx</code>语法的翻译。</p>
<ol>
<li><code>fiber</code> 对象</li>
</ol>
<p><code>fiber</code>对象是通过<code>ReactElement</code>对象进行创建的, 多个<code>fiber</code>对象构成了一棵<code>fiber</code>树, <code>fiber</code>树<br>是构造<code>DOM树</code>的数据模型, <code>fiber树</code>的任何改动, 最后都可以体现到<code>DOM</code>上。</p>
<p>为什么要引入<code>fiber</code>树呢，是因为如果直接用<code>ReactElement</code>对象渲染页面的话，只能一次递归处理完，这样浏览器呈现卡死的状态，但是使用<code>fiber</code>树渲染页面可以随时中断，将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。</p>
<h3 id="ReactElement-对象"><a href="#ReactElement-对象" class="headerlink" title="ReactElement 对象"></a><code>ReactElement</code> 对象</h3><p>jsx 转换为原生 js 需要通过一些诸如<code>babel</code>的编译工具。编译的过程把所有元素标签部分所有内容转换为 <code>React.createElement(...)</code>函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。</p>
<p>例如如下的<code>jsx</code>节点：</p>
<figure class="highlight tsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;className&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">style</span>=<span class="string">&quot;color: red&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">span</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>World<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>


<p>最终会被<code>React.createElement(...)</code>转化成如下的一个对象返回：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;div&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;id&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;div&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;className&quot;</span><span class="punctuation">:</span> <span class="string">&quot;className&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h3&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;style&quot;</span><span class="punctuation">:</span> <span class="string">&quot;color: red&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;span&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                        <span class="punctuation">&#123;</span></span><br><span class="line">                          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT_ELEMENT&quot;</span><span class="punctuation">,</span></span><br><span class="line">                          <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                            <span class="attr">&quot;nodeValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;hello&quot;</span><span class="punctuation">,</span></span><br><span class="line">                            <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">                          <span class="punctuation">&#125;</span></span><br><span class="line">                        <span class="punctuation">&#125;</span></span><br><span class="line">                      <span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                  <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;header&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">            <span class="punctuation">&#123;</span></span><br><span class="line">              <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;h2&quot;</span><span class="punctuation">,</span></span><br><span class="line">              <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                  <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;TEXT_ELEMENT&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;props&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">                      <span class="attr">&quot;nodeValue&quot;</span><span class="punctuation">:</span> <span class="string">&quot;World&quot;</span><span class="punctuation">,</span></span><br><span class="line">                      <span class="attr">&quot;children&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span></span><br><span class="line">                    <span class="punctuation">&#125;</span></span><br><span class="line">                  <span class="punctuation">&#125;</span></span><br><span class="line">                <span class="punctuation">]</span></span><br><span class="line">              <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">&#125;</span></span><br><span class="line">          <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>


<h3 id="fiber-对象"><a href="#fiber-对象" class="headerlink" title="fiber 对象"></a><code>fiber</code> 对象</h3><p>当 dom tree 很大的情况下，直接用<code>ReactElement</code> 对象渲染页面，页面上会是长时间的卡住状态，无法进行用户输入等交互操作。</p>
<p>可分为以下步骤解决上述问题：</p>
<ol>
<li>允许中断渲染工作，如果有优先级更高的工作插入，则暂时中断浏览器渲染，待完成该工作后，恢复浏览器渲染；</li>
<li>将渲染工作进行分解，分解成一个个小单元；</li>
</ol>
<p>步骤1可以使用浏览器的<code>requestIdleCallback</code>API解决允许中断渲染工作的问题，步骤2就需要引入<code>feiber</code>对象处理了。</p>
<p>假设需要渲染上述<code>ReactElement</code> 对象，生成的 <code>fiber</code>树如图：</p>
<img src="/2022/05/17/%E7%AB%99%E5%9C%A8React%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3React/Untitled.png" class="lazy" data-srcset="/2022/05/17/%E7%AB%99%E5%9C%A8React%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3React/Untitled.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="Untitled">

<p><code>fiber</code> 树的目标是非常容易找到下一个单元工作，这也是为什么每一个 <code>fiber</code> 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 <code>fiber</code> 上面的工作后，<code>fiber</code> 拥有 <code>child</code> 属性可以直接指向下一个需要进行工作的 <code>fiber</code> 节点。</p>
<p>当 <code>fiber</code>节点没有<code>child</code>也没兄弟节点时，我们去他们的<em>叔叔</em>（父节点的兄弟节点）节点，如果<code>fiber</code>的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次<code>render</code>我们完成了所有的工作。</p>
<h3 id="具体的渲染流程"><a href="#具体的渲染流程" class="headerlink" title="具体的渲染流程"></a>具体的渲染流程</h3><p>了解了两个最重要的对象和<code>requestIdleCallback</code>API后，React内部的渲染逻辑可以简单抽象为这样：</p>


<p>按照这个流程其实React第一次渲染时并不快，因为要额外生成fiber树，但是依靠fiber树这个数据结构，React更新是很快的，因为React保留了上次渲染完的fiber树。</p>
<h3 id="State的简单处理"><a href="#State的简单处理" class="headerlink" title="State的简单处理"></a>State的简单处理</h3><p>可以将State的信息挂在到当前的fiber对象中，这样每次SetState时，重新触发一次<code>workloop</code>就可以了。</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>这里只是针对<a href="https://www.tangdingblog.cn/blog/react/buildyourownreact-2020-09-22/#renderandcommit">建造属于你的react</a>  这篇文章做了简单的总结，具体的实现细节还是建议先把<a href="https://www.tangdingblog.cn/blog/react/buildyourownreact-2020-09-22/#renderandcommit">建造属于你的react</a>  这篇文章过一遍。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>1 <a href="https://www.tangdingblog.cn/blog/react/buildyourownreact-2020-09-22/#renderandcommit">建造属于你的react - 唐鼎的个人博客 (tangdingblog.cn)</a></p>
<p>2 <a href="https://mp.weixin.qq.com/s/Xab2Bu9yMPk6I5eeIedxjg">这可能是最通俗的 React Fiber 打开方式 (qq.com)</a></p>
<p>3 <a href="https://7kms.github.io/react-illustration-series/main/object-structure/">高频对象 - 图解React (7kms.github.io)</a></p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>用ts自制解释器1</title>
    <url>/2022/07/26/%E7%94%A8ts%E8%87%AA%E5%88%B6%E8%A7%A3%E9%87%8A%E5%99%A81/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近在读《用Go语言自制解释器》，由于对Go语言不是很熟悉，所以在阅读的过程中决定用typescript将代码实现一遍，加深印象。</p>
<h3 id="词法分析器"><a href="#词法分析器" class="headerlink" title="词法分析器"></a>词法分析器</h3><p>要解释源代码，就需要对其转换成易于处理的形式，一般的步骤是：</p>
<img src="/2022/07/26/%E7%94%A8ts%E8%87%AA%E5%88%B6%E8%A7%A3%E9%87%8A%E5%99%A81/image-20220727090642123.png" class="lazy" data-srcset="/2022/07/26/%E7%94%A8ts%E8%87%AA%E5%88%B6%E8%A7%A3%E9%87%8A%E5%99%A81/image-20220727090642123.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="image-20220727090642123">

<p>第一步是用词法分析器将源代码转换为词法单元 ，这一 过程称为词法分析。词法分析器也称词法单元生成器或扫描器。</p>
<p>词法分析器本身是短小，易于分类的数据结构，它会被传给语法分析器，语法分析器会将词法单元转换成抽象语法树。</p>
<h3 id="Monkey语言"><a href="#Monkey语言" class="headerlink" title="Monkey语言"></a>Monkey语言</h3><p>要解释的Monkey语言如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> ten = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> add = <span class="title function_">fn</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="title function_">add</span>(five, ten);</span><br><span class="line">!-<span class="comment">/*5;</span></span><br><span class="line"><span class="comment">5 &lt; 10 &gt; 5;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (5 &lt; 10) &#123;</span></span><br><span class="line"><span class="comment">	return true;</span></span><br><span class="line"><span class="comment">&#125; else &#123;</span></span><br><span class="line"><span class="comment">	return false;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="词法分析器实现思路"><a href="#词法分析器实现思路" class="headerlink" title="词法分析器实现思路"></a>词法分析器实现思路</h3><ol>
<li>整体思路：</li>
</ol>
<p>对源码进行挨个读取，去掉空格换行符等，然后进行分类： 关键字（<code>let if else</code>）、操作符（<code>+ - * /</code>）、分隔符（<code>, ; ( ) &#123; &#125;</code>）、标识符（ <code>add  x y params</code>）、数字（<code>123 45</code>）等。然后将读取的结果放到一个数组中，等待交给下一步的语法分析器处理。</p>
<ol start="2">
<li><p>这个过程主要是个体力活，没什么技巧，先枚举出所有的词法单元，然后词法分析器会遍历输入的字符，然后逐个输出识别出的词法单元，对于Monkey语言，所有的词法分类如下：</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非法字符和结束符</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ILLEGAL</span> = <span class="string">&quot;ILLEGAL&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">EOF</span> = <span class="string">&quot;EOF&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Identifiers + int  标识符和数字</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">IDENT</span> = <span class="string">&quot;IDENT&quot;</span>; <span class="comment">// add; foobar; x; y; ...</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">INT</span> = <span class="string">&quot;INT&quot;</span>; <span class="comment">// 1343456</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Operators</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASSIGN</span> = <span class="string">&quot;=&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">PLUS</span> = <span class="string">&quot;+&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">MINUS</span> = <span class="string">&quot;-&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">BANG</span> = <span class="string">&quot;!&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ASTERISK</span> = <span class="string">&quot;*&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SLASH</span> = <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LT</span> = <span class="string">&quot;&lt;&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">GT</span> = <span class="string">&quot;&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">EQ</span> = <span class="string">&quot;==&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">NOT_EQ</span> = <span class="string">&quot;!=&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Delimiters 分隔符</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">COMMA</span> = <span class="string">&quot;,&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">SEMICOLON</span> = <span class="string">&quot;;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LPAREN</span> = <span class="string">&quot;(&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">RPAREN</span> = <span class="string">&quot;)&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LBRACE</span> = <span class="string">&quot;&#123;&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">RBRACE</span> = <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Keywords 关键字</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">FUNCTION</span> = <span class="string">&quot;FUNCTION&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">LET</span> = <span class="string">&quot;LET&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">TRUE</span> = <span class="string">&quot;TRUE&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">FALSE</span> = <span class="string">&quot;FALSE&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">IF</span> = <span class="string">&quot;IF&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">ELSE</span> = <span class="string">&quot;ELSE&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">RETURN</span> = <span class="string">&quot;RETURN&quot;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Repl"><a href="#Repl" class="headerlink" title="Repl"></a>Repl</h3><p>用ts编写一个Repl:</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> readline <span class="keyword">from</span> <span class="string">&#x27;readline&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> os <span class="keyword">from</span> <span class="string">&quot;os&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ScannerClose</span> = &#123;</span><br><span class="line">  <span class="attr">exit</span>: <span class="string">&#x27;exit&#x27;</span>,</span><br><span class="line">  <span class="attr">quit</span>: <span class="string">&#x27;quit&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> exits = [<span class="title class_">ScannerClose</span>.<span class="property">exit</span>, <span class="title class_">ScannerClose</span>.<span class="property">quit</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> scanner = readline.<span class="title function_">createInterface</span>(&#123;</span><br><span class="line">  <span class="attr">input</span>: process.<span class="property">stdin</span>,</span><br><span class="line">  <span class="attr">output</span>: process.<span class="property">stdout</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">repl</span>(<span class="params"></span>) &#123;</span><br><span class="line">  scanner.<span class="title function_">question</span>(<span class="string">&#x27;&gt; &#x27;</span>, <span class="function">(<span class="params">input</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (exits.<span class="title function_">includes</span>(input)) <span class="keyword">return</span> scanner.<span class="title function_">close</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(input)</span><br><span class="line">    <span class="title function_">repl</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">startRepl</span>(<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(</span><br><span class="line">    <span class="string">`Hello <span class="subst">$&#123;os.userInfo().username&#125;</span>! This is the Monkey programming language!`</span></span><br><span class="line">  );</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Feel free to type in commands&quot;</span>);</span><br><span class="line">  <span class="title function_">repl</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><a href="https://github.com/laterbuy/ts-monkey/commit/bf95f914666fc211cdb3cd8226a522882276007a">ts-monkey</a></p>
]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>编译原理</tag>
        <tag>解释器</tag>
      </tags>
  </entry>
  <entry>
    <title>站在Vue2的角度理解Vue2</title>
    <url>/2022/05/05/%E7%AB%99%E5%9C%A8Vue2%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Vue2/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。</p>
<h3 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h3><p>Vue2的核心原理相对简单些，主要通过<code>Object.defineProperty</code> 对数据进行拦截，一个简单的数据拦截例子如下，会拦截Person对象上的name属性进行处理。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="title class_">Person</span> = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> temp = <span class="literal">null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params">val</span>) &#123;</span><br><span class="line">    temp = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<img src="/2022/05/05/%E7%AB%99%E5%9C%A8Vue2%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Vue2/image-20220704175618807-16569286501204.png" class="lazy" data-srcset="/2022/05/05/%E7%AB%99%E5%9C%A8Vue2%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Vue2/image-20220704175618807-16569286501204.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="" title="image-20220704175618807">

<h3 id="自定义实现代码"><a href="#自定义实现代码" class="headerlink" title="自定义实现代码"></a>自定义实现代码</h3><p>自定义vuejs部分</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">obj_instance</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">$data</span> = obj_instance.<span class="property">data</span>;</span><br><span class="line">    <span class="title class_">Observer</span>(<span class="variable language_">this</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="title class_">Complie</span>(obj_instance.<span class="property">el</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归数据劫持</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Observer</span>(<span class="params">data_instance</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!data_instance || <span class="keyword">typeof</span> data_instance !== <span class="string">&quot;object&quot;</span>) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">const</span> dependency = <span class="keyword">new</span> <span class="title class_">Dependency</span>();</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(data_instance).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 使用defineProperty后属性里的值会被修改 需要提前保存属性的值</span></span><br><span class="line">    <span class="keyword">let</span> value = data_instance[key];</span><br><span class="line">    <span class="title class_">Observer</span>(value);</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(data_instance, key, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// 收集数据依赖</span></span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title class_">Dependency</span>.<span class="property">temp</span> &amp;&amp; dependency.<span class="title function_">addSub</span>(<span class="title class_">Dependency</span>.<span class="property">temp</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 触发视图更新</span></span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newVal</span>) &#123;</span><br><span class="line">        value = newVal;</span><br><span class="line">        <span class="comment">// 处理赋值是对象时的情况</span></span><br><span class="line">        <span class="title class_">Observer</span>(newVal);</span><br><span class="line">        dependency.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//模板解析 —— 替换DOM内容 把vue实例上的数据解析到页面上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Complie</span>(<span class="params">element, vm</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">  vm.<span class="property">$el</span> = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(element);</span><br><span class="line">  <span class="keyword">const</span> fragment = <span class="variable language_">document</span>.<span class="title function_">createDocumentFragment</span>();</span><br><span class="line">  <span class="keyword">let</span> child;</span><br><span class="line">  <span class="keyword">while</span> ((child = vm.<span class="property">$el</span>.<span class="property">firstChild</span>)) &#123;</span><br><span class="line">    fragment.<span class="title function_">appendChild</span>(child);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">fragment_compile</span>(fragment);</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">fragment_compile</span>(<span class="params">node</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> pattern = <span class="regexp">/\&#123;\&#123;\s*(\S+)\s*\&#125;\&#125;/</span>;  <span class="comment">// &#123;&#123;&#125;&#125;</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="comment">// 提前保存文本内容 否则文本在被替换一次后 后续的操作都会不生效</span></span><br><span class="line">      <span class="keyword">const</span> texts = node.<span class="property">nodeValue</span>;</span><br><span class="line">      <span class="keyword">const</span> result_regex = pattern.<span class="title function_">exec</span>(node.<span class="property">nodeValue</span>);</span><br><span class="line">      <span class="keyword">if</span> (result_regex) &#123;</span><br><span class="line">        <span class="keyword">const</span> arr = result_regex[<span class="number">1</span>].<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>); <span class="comment">// more.salary =&gt; [&#x27;more&#x27;, &#x27;salary&#x27;]</span></span><br><span class="line">        <span class="comment">// 使用reduce归并获取属性对应的值 = vm.$data[&#x27;more&#x27;] =&gt; vm.$data[&#x27;more&#x27;][&#x27;salary&#x27;]</span></span><br><span class="line">        <span class="keyword">const</span> value = arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">        node.<span class="property">nodeValue</span> = texts.<span class="title function_">replace</span>(pattern, value);</span><br><span class="line">        <span class="comment">// 在节点值替换内容时 即模板解析的时候 添加订阅者</span></span><br><span class="line">        <span class="comment">// 在替换文档碎片内容时告诉订阅者如何更新 即告诉Watcher如何更新自己</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, result_regex[<span class="number">1</span>], <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">          node.<span class="property">nodeValue</span> = texts.<span class="title function_">replace</span>(pattern, newVal);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 替换绑定了v-model属性的input节点的内容</span></span><br><span class="line">    <span class="keyword">if</span> (node.<span class="property">nodeType</span> === <span class="number">1</span> &amp;&amp; node.<span class="property">nodeName</span> === <span class="string">&quot;INPUT&quot;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> attr = <span class="title class_">Array</span>.<span class="title function_">from</span>(node.<span class="property">attributes</span>);</span><br><span class="line">      attr.<span class="title function_">forEach</span>(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (item.<span class="property">nodeName</span> === <span class="string">&quot;v-model&quot;</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> value = item.<span class="property">nodeValue</span></span><br><span class="line">            .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">            .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">          node.<span class="property">value</span> = value;</span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">Watcher</span>(vm, item.<span class="property">nodeValue</span>, <span class="function">(<span class="params">newVal</span>) =&gt;</span> &#123;</span><br><span class="line">            node.<span class="property">value</span> = newVal;</span><br><span class="line">          &#125;);</span><br><span class="line">          node.<span class="title function_">addEventListener</span>(<span class="string">&quot;input&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;, &#x27;salary&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr1 = item.<span class="property">nodeValue</span>.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">            <span class="comment">// [&#x27;more&#x27;]</span></span><br><span class="line">            <span class="keyword">const</span> arr2 = arr1.<span class="title function_">slice</span>(<span class="number">0</span>, arr1.<span class="property">length</span> - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// vm.$data.more</span></span><br><span class="line">            <span class="keyword">const</span> final = arr2.<span class="title function_">reduce</span>(</span><br><span class="line">              <span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current],</span><br><span class="line">              vm.<span class="property">$data</span></span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// vm.$data.more[&#x27;salary&#x27;] = e.target.value</span></span><br><span class="line">            final[arr1[arr1.<span class="property">length</span> - <span class="number">1</span>]] = e.<span class="property">target</span>.<span class="property">value</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">childNodes</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">child</span>) =&gt;</span> <span class="title function_">fragment_compile</span>(child));</span><br><span class="line">  &#125;</span><br><span class="line">  vm.<span class="property">$el</span>.<span class="title function_">appendChild</span>(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//依赖 —— 实现发布-订阅模式 用于存放订阅者和通知订阅者更新</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dependency</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span> = []; <span class="comment">// 用于收集依赖data的订阅者信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addSub</span>(<span class="params">sub</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">push</span>(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">subscribers</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">sub</span>) =&gt;</span> sub.<span class="title function_">update</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Watcher</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">vm, key, callback</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">vm</span> = vm;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">key</span> = key;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">callback</span> = callback;</span><br><span class="line">    <span class="comment">//临时属性 —— 触发getter 收集数据依赖</span></span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="variable language_">this</span>;</span><br><span class="line">    key.<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>).<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], vm.<span class="property">$data</span>);</span><br><span class="line">    <span class="comment">// 防止订阅者多次加入到依赖实例数组里</span></span><br><span class="line">    <span class="title class_">Dependency</span>.<span class="property">temp</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">update</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="property">key</span></span><br><span class="line">      .<span class="title function_">split</span>(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">      .<span class="title function_">reduce</span>(<span class="function">(<span class="params">total, current</span>) =&gt;</span> total[current], <span class="variable language_">this</span>.<span class="property">vm</span>.<span class="property">$data</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">callback</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相关html</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>name &#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;name&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">span</span>&gt;</span>desc &#123;&#123;more.desc&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;more.desc&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="keyword">const</span> vm = <span class="keyword">new</span> <span class="title class_">Vue</span>(&#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="attr">data</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span>,</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            <span class="attr">more</span>: &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="attr">desc</span>: <span class="number">1000</span></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">window</span>.<span class="property">vm</span> = vm</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol>
<li><a href="https://www.bilibili.com/video/BV1934y1a7MN?spm_id_from=333.999.0.0">Vue.js 数据双向绑定的原理及实现</a></li>
</ol>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>简单的Electron监控</title>
    <url>/2023/03/17/%E7%AE%80%E5%8D%95%E7%9A%84Electron%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>前端需要做一个简单的监控方案，只需要监控到页面的异常和性能即可。</p>
<h3 id="监控方案"><a href="#监控方案" class="headerlink" title="监控方案"></a>监控方案</h3><h4 id="以用户体验为中心的性能指标"><a href="#以用户体验为中心的性能指标" class="headerlink" title="以用户体验为中心的性能指标"></a>以用户体验为中心的性能指标</h4><p>侧重于用户体验的三个方面——加载性能、交互性和视觉稳定性——并包括以下指标（及各指标相应的阈值）：</p>
<img src="/2023/03/17/%E7%AE%80%E5%8D%95%E7%9A%84Electron%E7%9B%91%E6%8E%A7/01.png" class="lazy" data-srcset="/2023/03/17/%E7%AE%80%E5%8D%95%E7%9A%84Electron%E7%9B%91%E6%8E%A7/01.png" srcset="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABlBMVEXMzMyWlpYU2uzLAAAACXBIWXMAAA7EAAAOxAGVKw4bAAAACklEQVQImWNgAAAAAgAB9HFkpgAAAABJRU5ErkJggg==" class="">

<ul>
<li><a href="https://web.dev/lcp/">Largest Contentful Paint (LCP)</a> ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。</li>
<li><a href="https://web.dev/fid/">First Input Delay (FID)</a> ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。</li>
<li><a href="https://web.dev/cls/">Cumulative Layout Shift (CLS)</a> ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。</li>
</ul>
<p>这三个指标都可以通过 <code>Performance</code> 接口获直接或者间接获取到，当然谷歌提供了完成的解决方案 <a href="https://www.npmjs.com/package/web-vitals">web-vitals</a>:</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; onLCP, onFID, onCLS &#125; <span class="keyword">from</span> <span class="string">&#x27;web-vitals&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">onCLS</span>(monitorPref); </span><br><span class="line"><span class="title function_">onFID</span>(monitorPref);</span><br><span class="line"><span class="title function_">onLCP</span>(monitorPref); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="内存监控"><a href="#内存监控" class="headerlink" title="内存监控"></a>内存监控</h4><p>浏览器在 <code>performance</code> 对象上加上了 <code>memory</code> 属性，通过获取 <code>performance.memory</code> 可以得到一组当前页面使用内存数据的信息。具体如下：</p>
<ul>
<li><code>jsHeapSizeLimit</code>：表示当前页面最多可以获得的 JavaScript 堆大小；</li>
<li><code>totalJSHeapSize</code>：表示当前页面已经分配的 JavaScript 堆大小；</li>
<li><code>usedJsHeapSize</code>：表示当前页面 JavaScript 已经使用的堆大小。</li>
</ul>
<p>浏览器在分配内存的时候，会一次性向系统申请一块内存，然后在 JavaScript 需要的时候直接提供使用，因而 <code>totalJSHeapSize</code> 总是大于 <code>usedJsHeapSize</code> 的。如果 JavaScript 需要的内存多于已经申请的量，就会继续申请一块，直到达到 <code>jsHeapSizeLimit</code> 的上限，触发页面崩溃。</p>
<p>通过观察 <code>jsHeapSizeLimit</code> 和 <code>totalJSHeapSize</code> 这两个字段，可以用于监控当前的页面是否有耗尽内存的危险；同时，如果内存一直在涨，不见回落，很可能需要排查是否有潜在的内存泄漏危险。</p>
<p>Electron的nodejs端同理，用<code>process.getHeapStatistics()</code>获取内存相关数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// web端</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">const</span> memory = performance.<span class="property">memory</span>;</span><br><span class="line">    <span class="comment">// # bytes / KB / MB / GB</span></span><br><span class="line">    <span class="keyword">const</span> limit =</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>((memory[<span class="string">&quot;jsHeapSizeLimit&quot;</span>] / <span class="number">1024</span> / <span class="number">1024</span>) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> total =</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>((memory[<span class="string">&quot;totalJSHeapSize&quot;</span>] / <span class="number">1024</span> / <span class="number">1024</span>) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (limit - total &lt; <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;memory leak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(`Heap limit $&#123;limit&#125; MB`);</span></span><br><span class="line">    <span class="comment">// console.log(`Heap total $&#123;total&#125; MB`);</span></span><br><span class="line">  &#125;, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 主进程端</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    <span class="keyword">const</span> memory = process.<span class="title function_">getHeapStatistics</span>();</span><br><span class="line">    <span class="keyword">const</span> limit =</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>((memory[<span class="string">&quot;heapSizeLimit&quot;</span>] / <span class="number">1024</span>) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">const</span> total =</span><br><span class="line">      <span class="title class_">Math</span>.<span class="title function_">round</span>((memory[<span class="string">&quot;totalHeapSize&quot;</span>] / <span class="number">1024</span>) * <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (limit - total &lt; <span class="number">500</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;memory leak&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// console.log(`Heap limit $&#123;limit&#125; MB`);</span></span><br><span class="line">    <span class="comment">// console.log(`Heap total $&#123;total&#125; MB`);</span></span><br><span class="line">  &#125;, <span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h4 id="Electron崩溃监控"><a href="#Electron崩溃监控" class="headerlink" title="Electron崩溃监控"></a>Electron崩溃监控</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 渲染进程崩溃</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;render-process-gone&#x27;</span>, <span class="function">(<span class="params">event, webContents, details</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;app:render-process-gone&#x27;</span>, event, webContents, details);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 子进程崩溃</span></span><br><span class="line">app.<span class="title function_">on</span>(<span class="string">&#x27;child-process-gone&#x27;</span>, <span class="function">(<span class="params">event, details</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&#x27;app:child-process-gone&#x27;</span>, event, details);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="异常捕获"><a href="#异常捕获" class="headerlink" title="异常捕获"></a>异常捕获</h4><ol>
<li><p>代码异常和资源加载异常</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;error&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">type</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">  <span class="keyword">if</span> (event.<span class="property">target</span> <span class="keyword">instanceof</span> <span class="title class_">Image</span>) &#123; <span class="comment">// 资源加载异常</span></span><br><span class="line">     <span class="keyword">type</span> = <span class="string">&#x27;resource error&#x27;</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.<span class="property">target</span> <span class="keyword">instanceof</span> <span class="title class_">HTMLLinkElement</span>) &#123; <span class="comment">// 资源加载异常</span></span><br><span class="line">     <span class="keyword">type</span> = <span class="string">&#x27;resource error&#x27;</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">type</span> = <span class="string">&#x27;code error&#x27;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码报错和promise报错</p>
<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;unhandledrejection&#x27;</span>, <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; reason, timeStamp &#125; = event;</span><br><span class="line">    <span class="keyword">const</span> &#123; message, stack &#125; = reason;</span><br><span class="line">    <span class="keyword">const</span> url = <span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">type</span> = <span class="string">&#x27;code error&#x27;</span>;</span><br><span class="line">    log.<span class="title function_">error</span>(&#123; message, stack, url, timeStamp, <span class="keyword">type</span> &#125;);</span><br><span class="line">  &#125;, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>http请求异常，这个一般会封装到全局的<code>fetch</code>方法里统一处理</p>
</li>
</ol>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol>
<li><a href="https://juejin.cn/post/7100841779854835719/#heading-23">一文摸清前端监控自研实践（三）错误监控</a></li>
<li><a href="https://web.dev/vitals/">Web 指标</a></li>
<li><a href="https://www.npmjs.com/package/web-vitals">web-vitals</a></li>
<li><a href="https://segmentfault.com/a/1190000041265668">你需要了解的Node.js内存限制</a></li>
</ol>
]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>Electron</tag>
      </tags>
  </entry>
  <entry>
    <title>给现有的项目中添加一个文档工具</title>
    <url>/2022/07/28/%E7%BB%99%E7%8E%B0%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>前端项目开发到一定程度，各种抽象出来的组件就变得难以识别和维护，这时候就急需一个文档工具，理论上集成一下<a href="https://www.docz.site/">docz</a>或者<a href="https://d.umijs.org/zh-CN">dumi</a>即可，但是这两个项目由于依赖冲入，配置冲突，资源加载等原因集成进去已有的项目是非常困难的，各种报错。</p>
<h3 id="造轮子思路"><a href="#造轮子思路" class="headerlink" title="造轮子思路"></a>造轮子思路</h3><p>在现有的背景下自己根据需求实现一个是比较理想的，以umi项目为例，只需要将<code>src/components/myComponent</code> 目录下的mdx文件转换为react组件即可，然后新开一个路由将转换的react组件全部加载进来即可。</p>
<h3 id="转换组件"><a href="#转换组件" class="headerlink" title="转换组件"></a>转换组件</h3><p>首先需要转换和解析组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i xdm remark-frontmatter remark-mdx-frontmatter @mdx-js/react highlight.js</span><br></pre></td></tr></table></figure>

<h3 id="批量转换脚本"><a href="#批量转换脚本" class="headerlink" title="批量转换脚本"></a>批量转换脚本</h3><p>约定：每个组件中的文档文件命名为<code>doc.mdx</code>，转换后的文档文件命名为<code>doc.js</code>,这样将每个组件下的文档文件进行批量转换：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="comment">// genDoc.js</span></span><br><span class="line"><span class="keyword">import</span> fs, &#123; writeFileSync, readFileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> remarkFrontmatter <span class="keyword">from</span> <span class="string">&#x27;remark-frontmatter&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> remarkMdxFrontmatter <span class="keyword">from</span> <span class="string">&#x27;remark-mdx-frontmatter&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; compileSync &#125; <span class="keyword">from</span> <span class="string">&#x27;xdm&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> comPath = path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;src/components&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> comDirs = fs.<span class="title function_">readdirSync</span>(comPath);</span><br><span class="line"></span><br><span class="line">comDirs.<span class="title function_">forEach</span>(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> docMdxPath = path.<span class="title function_">resolve</span>(comPath, v, <span class="string">&#x27;doc.mdx&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (fs.<span class="title function_">existsSync</span>(docMdxPath)) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; value &#125; = <span class="title function_">compileSync</span>(<span class="title function_">readFileSync</span>(docMdxPath), &#123;</span><br><span class="line">      <span class="attr">jsx</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">providerImportSource</span>: <span class="string">&#x27;@mdx-js/react&#x27;</span>,</span><br><span class="line">      <span class="attr">remarkPlugins</span>: [remarkFrontmatter, remarkMdxFrontmatter],</span><br><span class="line">      <span class="attr">rehypePlugins</span>: [rehypeHighlight],</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">writeFileSync</span>(path.<span class="title function_">resolve</span>(comPath, v, <span class="string">&#x27;doc.js&#x27;</span>), value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="文档路由切换"><a href="#文档路由切换" class="headerlink" title="文档路由切换"></a>文档路由切换</h3><p>.umirc.ts文件修改</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> docRoutes = [&#123; <span class="attr">path</span>: <span class="string">&#x27;/doc&#x27;</span>, <span class="attr">component</span>: <span class="string">&#x27;@/pages/doc&#x27;</span> &#125;]</span><br><span class="line">...</span><br><span class="line"><span class="attr">routes</span>: process.<span class="property">env</span>.<span class="property">mode</span> === <span class="string">&#x27;doc&#x27;</span> ? docRoutes : routes,</span><br></pre></td></tr></table></figure>

<p>package.json文件添加doc命令</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;doc&quot;</span>: <span class="string">&quot;node genDoc &amp;&amp; cross-env mode=doc umi dev&quot;</span>,</span><br></pre></td></tr></table></figure>

<p>这样执行<code>npm run doc</code> 时，可以快速仅启动文档路由</p>
<h3 id="路由文件"><a href="#路由文件" class="headerlink" title="路由文件"></a>路由文件</h3><p>加入动态生成路由文件后就基本完成任务了，现在只需要关注编写mdx文档了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// genDoc.js</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 动态生成路由文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTemplate</span> = (<span class="params">docPaths</span>) =&gt;  <span class="string">`</span></span><br><span class="line"><span class="string">import &#123; MDXProvider &#125; from &#x27;@mdx-js/react&#x27;;</span></span><br><span class="line"><span class="string">import &#123; useState &#125; from &#x27;react&#x27;;</span></span><br><span class="line"><span class="string">import styles from &#x27;./index.less&#x27;;</span></span><br><span class="line"><span class="string">import &#x27;highlight.js/styles/github.css&#x27;;</span></span><br><span class="line"><span class="string"><span class="subst">$&#123;docPaths.map(v =&gt; <span class="string">`import <span class="subst">$&#123;v&#125;</span>Doc, &#123; title as <span class="subst">$&#123;v&#125;</span>Title &#125; from &#x27;@/components/<span class="subst">$&#123;v&#125;</span>/doc.js&#x27;;`</span>).join(<span class="string">&#x27;\\n&#x27;</span>)&#125;</span></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">const Doc = () =&gt; &#123;</span></span><br><span class="line"><span class="string">  const titles = [<span class="subst">$&#123;docPaths.map(v =&gt; <span class="string">`<span class="subst">$&#123;v&#125;</span>Title`</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>];</span></span><br><span class="line"><span class="string">  const contents = [<span class="subst">$&#123;docPaths.map(v =&gt; <span class="string">`<span class="subst">$&#123;v&#125;</span>Doc`</span>).join(<span class="string">&#x27;,&#x27;</span>)&#125;</span>];</span></span><br><span class="line"><span class="string">  const [cur, setCur] = useState(0)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  return (</span></span><br><span class="line"><span class="string">    &lt;div&gt;</span></span><br><span class="line"><span class="string">      &#123;titles.map((v, i) =&gt; &lt;div onClick=&#123;() =&gt; setCur(i)&#125;&gt;&#123;v&#125;&lt;/div&gt;)&#125;</span></span><br><span class="line"><span class="string">      &#123;/* @ts-ignore */&#125;</span></span><br><span class="line"><span class="string">      &lt;MDXProvider&gt;</span></span><br><span class="line"><span class="string">        &#123;contents[cur]()&#125;</span></span><br><span class="line"><span class="string">      &lt;/MDXProvider&gt;</span></span><br><span class="line"><span class="string">    &lt;/div&gt;</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">export default Doc;</span></span><br><span class="line"><span class="string">`</span></span><br><span class="line"><span class="keyword">const</span> template = <span class="title function_">getTemplate</span>(docComDirs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> docPath = path.<span class="title function_">resolve</span>(process.<span class="title function_">cwd</span>(), <span class="string">&#x27;src/pages/doc/index.tsx&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">writeFileSync</span>(docPath, template)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
        <tag>工具</tag>
      </tags>
  </entry>
</search>
