# 数据库的简单实现1

Description: 最简单的K-V数据库后端实现
Public: No
Published: 2022/03/09
Tags: 数据库

这里将用TypeScript开始实现一个最简单的 Key-Value 数据库，以理解数据库是怎么工作的。

### ****建立 REPL 环境****

首先要建立建立 REPL 环境，这样就可以在终端输入语句，然后查看输出，并不断进行这个循环直到停止使用。

Node.js 的标准库本身提供了一个叫 `repl`的模块，只需要几行代码，就可以非常迅速的建立起一个 REPL 环境。

```jsx
repl.start({
  prompt: 'db.js >> ',
  eval: (evalCmd) => {
    callback(null, `Unrecognized command ${evalCmd}`)
  },
});
```

使用 `ts-node`这样的工具来直接运行这个文件，就可以跑起来了。为了测试，试试输入 `test`并回车，可以看到下面这样的输出：

```jsx
db.js >> test
Unrecognized command 'test'
```

### 最简单的实现

实现一个将数据存储到硬盘上的数据库，这样即使进程退出数据也不会丢失。

实现思路：直接把数据序列化以后作为文本塞到文件的最后，同时把键和值用逗号分割。每当读取数据时，扫描这个文件来一行一行遍历查询键名。

```jsx
import fs from 'fs';
import readline from 'readline';

const dbFile = './data.db';

const get = (key: string) => {
  const readable = fs.createReadStream(dbFile);
  const reader = readline.createInterface({ input: readable });
  return new Promise<string>(resolve => {
    let value: any;
    reader.on('line', line => {
      const [k, v] = line.split(',');
      if (k === key) {
        value = v;
      }
    });
    readable.on('end', () => {
      reader.close();
      resolve(value);
    });
  });
};

const set = (key: string, value: any) => {
  fs.appendFileSync(dbFile, `${key},${value}\n`);
};
```

然后简单的修改一下 `eval` 参数以接入 `set` 和 `get` 接口，可以先不管解析 SQL 语句之类的事情，使用一个最简单的语法，

- `set [key] [value]`
- `get [key]`

语法的解析也是暂时假定所有的输入都是正确的格式，这样可以用非常简单的方式来实现：

```jsx
const replServer = repl.start({
  // ...
  eval: async (evalCmd, _, __, callback) => {
    const cmd = evalCmd.trim();
    if (cmd.startsWith("set")) {
      const [, key, value] = cmd.split(" ");
      set(key, value);
      return callback(null, value);
    }
    if (cmd.startsWith("get")) {
      const [, key] = cmd.split(" ");
      const value = await get(key);
      return callback(null, value);
    }
    return callback(null, `Unrecognized command ${evalCmd}`);
  },
});
```

启动以后测试一下，可以看到已经成功了：

```
db.js >> set a aaa
'aaa'
db.js >> set b bbb
'bbb'
db.js >> get a
'aaa'
db.js >> set a ccc
'ccc'
db.js >> get a
'ccc'
```

`set` 函数在简单的场景性能其实非常好，因为在文件尾部追加写入其实是很高效的，像很多日志的实现，都是一个 **append-only** 的文件，虽然还有像并发，容错等很多额外的事情要处理，但核心原理是一样的。

但对于读取数据的 `get` 操作，它的性能则非常糟糕，因为每次必须从头到尾扫描整个文件来进行查找。从算法的角度来说，它的复杂度是 **O(N)** 。也就是说随着数据量的增大，查找的时间也会线性增长。要解决这个问题，需要引入一个叫 **索引** 的额外结构，比如查汉语字典时，可以根据偏旁部首或者拼音，在目录中找到他们的大概位置，直接翻到那一页再仔细一条条查找，索引的概念和目录就是一样的。

同时还有一个问题，在存储时将所有的值序列化为字符串再作为文本直接写入到文件中，同时使用逗号分隔键和值，这个叫 **CSV (comma-separated values)** 格式，写入时会默认使用 UTF-8 的编码格式，每一个 UTF-8 字符会使用 1-4 个字节来存储，但对某些值来说，将其转化成字符串有可能会增大它的体积，例如布尔值完全可以用一个 bit 位来代替，而转变成了字符串 "true" 在 UTF-8 中则变成了 4 个字节。

使用文本格式的最大优点，是提供给了人类一个很好的可读性，事实上 MySQL 确实就有一个[CSV 存储引擎](https://dev.mysql.com/doc/refman/5.7/en/csv-storage-engine.html)。但在绝大多数情况下，文本格式并不是一个最佳选择，毕竟提供给人类可读性并不是一个很高优的目标，而使用二进制格式能有更好的性能表现。

虽然用 Node.js 来实现肯定不会有太好的性能，但这个学习过程中会像设计一个真正的数据库一样去思考。在 Node 中可以利用 `[Buffer](https://nodejs.org/api/buffer.html#buffer)` 来实现对二进制数据进行操作，因此后续会将文本格式改为二进制格式。

- 最后附上完整的代码：
    
    ```tsx
    import * as repl from "repl";
    import * as fs from "fs";
    import * as readline from "readline";
    import * as path from "path";
    
    const dbFile = "./data.db";
    
    /**
     * @description: 从 db文件中遍历所有行找数据
     * @param {string} key
     * @return {*}
     */
    const get = (key: string) => {
      const readable = fs.createReadStream(dbFile);
      const reader = readline.createInterface({ input: readable });
      return new Promise<string>((resolve) => {
        let value: string;
        reader.on("line", (line: string) => {
          const [k, v] = line.split(",");
          if (k === key) {
            value = v;
          }
        });
        readable.on("end", () => {
          reader.close();
          resolve(value);
        });
      });
    };
    
    /**
     * @description: 写数据
     * @param {string} key
     * @param {string} value
     * @return {*}
     */
    const set = (key: string, value: string) => {
      fs.appendFileSync(dbFile, `${key},${value}\n`);
    };
    
    /**
     * @description: 检查DB文件是否存在，不存在则创建
     * @param {string} filePath
     * @return {*}
     */
    const checkFiles = (filePath: string) => {
      const p = path.resolve(process.cwd(), filePath);
      const exist = fs.existsSync(p);
      if (!exist) {
        fs.writeFileSync(p, "");
      }
    };
    
    repl.start({
      prompt: "db.js >> ",
      eval: async (evalCmd, _context, _file, callback) => {
        checkFiles(dbFile);
        const cmd = evalCmd.trim();
        if (cmd.startsWith("set")) {
          const [, key, value] = cmd.split(" ");
          set(key, value);
          return callback(null, value);
        }
        if (cmd.startsWith("get")) {
          const [, key] = cmd.split(" ");
          const value = await get(key);
          return callback(null, value);
        }
        return callback(null, `Unrecognized command ${evalCmd}`);
      },
    });
    ```
    

### 参考

****Build a Simple Database****