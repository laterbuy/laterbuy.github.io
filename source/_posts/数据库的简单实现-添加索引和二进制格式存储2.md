---
title: 添加索引和二进制格式存储（数据库的简单实现2）
description: 添加索引和二进制格式存储
date: 2022/03/16
updated: 2022/03/16
tags:
  - 数据库
  - 数据库的简单实现2
categories:
  - 数据库
---

### 索引

索引是从主数据衍生出来的额外结构，添加和删除索引完全不会影响数据，只会影响查询的性能。维护这个结构会产生一些开销，因为需要在写入的时候多做一点操作，去更新索引，这样才能在读取的时候利用索引来加快一点速度。任何类型的索引通常都会减慢写入速度，因此数据库默认并不会索引所有的内容，而是需要用户来根据自己的情况做出取舍来手动选择索引，尽量选择那些带来较大收益而且又不会引入超出必要开销的索引。

### 哈希索引

之前实现的简单数据库，可以使用`Map`来索引文件中的数据，假设依然是追加写入的文件，和之前一样，可以设计一个最简单的索引策略：保留一个内存中的散列映射，其中每个键都映射到数据文件中的一个字节偏移量，指明了可以找到对应值的位置。

### 为数据库加上索引并把存储格式改为二进制

接下来开始实现一个最简单的保存在内存中的哈希索引，这在 Node 环境中非常简单，只需要用一个 `Map`就可以。数据存储为二进制后，可以将数据看成一个大的数组，读取数据只需要知道数据的下标和数据的大小就可以:

```tsx
type Offset = number;
type Size = number; // how many bytes
type Index = [Offset, Size];

const map = new Map<string, Index>();
```

对于不同的数据类型，需要针对性的将其转换为二进制，简单起见，暂时只支持三种数据类型，分别是数字、布尔值和字符串:

```tsx
const enum DataType {  Boolean,  Number,  String,}
```

针对这三个类型编写一个序列化的函数，同时，为了在读取时针对性的进行反序列化，我们还需要将它的类型信息也存进去，规则是下面这样的：

- 每一个数据都用第一个字节来存储它的类型信息，0，1，2 分别对应布尔值，数字和字符串；
- 布尔值，用一个字节来表示（主要是 Node 最少得分配一个字节），1 为 true，0 为 false；
- 数字，因为 Node 中的普通数字实际上都是双精度浮点数，我们就将其都作为 double 处理，占用 8 个字节（64 位），对于可能溢出的大数字先不管；
- 除了布尔和数字，其他都当做字符串处理，采用 UTF-8 编码。

```tsx
const serialize = (val: boolean | number | string): Buffer => {
  let buf: Buffer;
  let type: Buffer;
  let data: Buffer;

  switch (typeof val) {
    case 'boolean': {
      type = Buffer.alloc(1, DataType.Boolean);
      data = Buffer.alloc(1, val ? 1 : 0);
      break;
    }
    case 'number': {
      type = Buffer.alloc(1, DataType.Number);
      data = Buffer.allocUnsafe(8);
      data.writeDoubleBE(val);
      break;
    }
    case 'string': {
      type = Buffer.alloc(1, DataType.String);
      data = Buffer.from(val);
      break;
    }
    default: {
      type = Buffer.alloc(1, DataType.String);
      data = Buffer.from(val);
    }
  }

  buf = Buffer.concat([type, data]);
  return buf;
};
```

注意数字的部分用到了 `buffer.writeDoubleBE`，`BE`的意思是 **Big-Endian**，中文叫大端序，还有一种叫小端序，对于[字节序](https://en.wikipedia.org/wiki/Endianness)这里不赘述。具体使用什么样的字节序没什么讲究，重要的是在序列化和反序列化的时候一定要使用相同的字节序，这里我们默认全部使用大端序。

反序列化也很简单：

```jsx
const deserialize = (buf: Buffer): boolean | number | string => {
  const type = buf[0];

  switch (type) {
    case DataType.Boolean: {
      return buf[1] === 1;
    }
    case DataType.Number: {
      return buf.readDoubleBE(1);
    }
    case DataType.String: {
      return buf.slice(1).toString();
    }
    default:
      return buf.slice(1).toString();
  }
};
```

整体的思路就确定了：

- 启动时先获取数据库文件 fd，开启 repl 环境；
- 对于 set 命令把 key/value 交给 `set` 函数，进行序列化，先更新索引，再写入文件；
- 对于 get 命令解析出 key，交给 `get` 函数，先从索引中查找，如果有的话根据偏移位置和数据大小，然后直接读取出来并进行反序列化然后返回。

可以重构一下之前的 `get`和 `set`函数：

```jsx
const get = (key: string) => {
  const index = map.get(key);

  if (index) {
    const [offset, size] = index;
    const buffer = Buffer.alloc(size);
    fs.readSync(fd, buffer, 0, size, offset);
    return deserialize(buffer);
  }

  return null;
};

const set = (key: string, value: string) => {
  let buffer: Buffer;
  if (value === 'true' || value === 'false') {
    // boolean
    buffer = serialize(JSON.parse(value));
  } else if (/^-?\d+$/.test(value)) {
    // number
    buffer = serialize(parseFloat(value));
  } else {
    buffer = serialize(value);
  }

  const size = buffer.byteLength;
  const offset = fs.statSync(dbFile).size;
  map.set(key, [offset, size]);
  fs.appendFileSync(dbFile, buffer);
};
```

使用 `ts-node main.ts`来直接启动并进行测试。

最后附上完整的代码：

```tsx
import * as repl from 'repl';
import * as fs from 'fs';
import * as path from 'path';

const dbFile = './data.db';

type Offset = number;
type Size = number; // how many bytes
type Index = [Offset, Size];

const map = new Map<string, Index>();
const fd = fs.openSync(dbFile, 'a+'); // `a+` flag means open file for reading and appending.

const enum DataType {
  Boolean,
  Number,
  String,
}

/**
 * @description: 从 db文件中遍历所有行找数据
 * @param {string} key
 * @return {*}
 */
const get = (key: string) => {
  const index = map.get(key);
  if (index) {
    const [offset, size] = index;
    const buffer = Buffer.alloc(size);
    fs.readSync(fd, buffer, 0, size, offset);
    return deserialize(buffer);
  }

  return null;
};

/**
 * @description: 写数据
 * @param {string} key
 * @param {string} value
 * @return {*}
 */
const set = (key: string, value: string) => {
  let buffer: Buffer;
  if (value === 'true' || value === 'false') {
    // boolean
    buffer = serialize(JSON.parse(value));
  } else if (/^-?\d+$/.test(value)) {
    // number
    buffer = serialize(parseFloat(value));
  } else {
    buffer = serialize(value);
  }

  const size = buffer.byteLength;
  const offset = fs.statSync(dbFile).size;
  map.set(key, [offset, size]);
  fs.appendFileSync(dbFile, buffer);
};

/**
 * @description: 反序列化函数
 * @param {boolean} val
 * @return {*}
 */
const deserialize = (buf: Buffer): boolean | number | string => {
  const type = buf[0];

  switch (type) {
    case DataType.Boolean: {
      return buf[1] === 1;
    }
    case DataType.Number: {
      return buf.readDoubleBE(1);
    }
    case DataType.String: {
      return buf.slice(1).toString();
    }
    default:
      return buf.slice(1).toString();
  }
};

/**
 * @description: 序列化函数
 * @param {boolean} val
 * @return {*}
 */
const serialize = (val: boolean | number | string): Buffer => {
  let buf: Buffer;
  let type: Buffer;
  let data: Buffer;

  switch (typeof val) {
    case 'boolean': {
      type = Buffer.alloc(1, DataType.Boolean);
      data = Buffer.alloc(1, val ? 1 : 0);
      break;
    }
    case 'number': {
      type = Buffer.alloc(1, DataType.Number);
      data = Buffer.allocUnsafe(8);
      data.writeDoubleBE(val);
      break;
    }
    case 'string': {
      type = Buffer.alloc(1, DataType.String);
      data = Buffer.from(val);
      break;
    }
    default: {
      type = Buffer.alloc(1, DataType.String);
      data = Buffer.from(val);
    }
  }

  buf = Buffer.concat([type, data]);
  return buf;
};

/**
 * @description: 检查DB文件是否存在，不存在则创建
 * @param {string} filePath
 * @return {*}
 */
const checkFiles = (filePath: string) => {
  const p = path.resolve(process.cwd(), filePath);
  const exist = fs.existsSync(p);
  if (!exist) {
    fs.writeFileSync(p, "");
  }
};

repl.start({
  prompt: 'db.js >> ',
  eval: async (evalCmd, _context, _file, callback) => {
    checkFiles(dbFile);
    const cmd = evalCmd.trim();
    if (cmd.startsWith('set')) {
      const [, key, value] = cmd.split(' ');
      set(key, value);
      return callback(null, value);
    }
    if (cmd.startsWith('get')) {
      const [, key] = cmd.split(' ');
      const value = get(key);
      return callback(null, value);
    }
    return callback(null, `Unrecognized command ${evalCmd}`);
  },
});
```


### 参考

[Build a simple database with Node.js (db-js.vercel.app)](https://db-js.vercel.app/4)