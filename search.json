[{"title":"存储引擎-简介","date":"2022-08-23T16:00:00.000Z","url":"/2022/08/24/%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-%E7%AE%80%E4%BB%8B/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["存储","/tags/%E5%AD%98%E5%82%A8/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["存储","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AD%98%E5%82%A8/"]],"content":"数据存储与检索背景数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 维度 OLTP(online transaction processing) OLAP(online analysis processing) 系统功能 日常交易处理&#x2F;在线失误处理 统计、分析、报表&#x2F;在线分析处理 设计目标 面向实时交易类应用 面向统计分析类应用 数据处理 当前的、最新的 历史的、聚集的 实时性 实时性读写要求高 实时性读写要求低 事务 强事务 弱事务 分析要求 低、简单 高、复杂 OLTP大多数OLTP系统中，数据存储都是以面向行(row-oriented)的方式组织的。这种方式把一行数据存放在一起。在OLAP系统中，查询语句一般是获取大量行数据中的特定某几列。 OLTP的存储引擎分为面向页（b+tree）存储引擎和日志结构（lsm tree）存储引擎 数据文件和索引文件数据库系统的主要目的是存储数据和快速检索数据。为了实现快速检索数据会以特殊的格式来保存到文件中。特殊的存储格式可以确保： 存储效率最高：存储每条数据记录的额外开销最小。 访问效率最高：数据记录能够以最少的步骤被访问。 更新效率最高：对磁盘数据做最少改动就能完成记录更新。 数据库系统的表中存储了由多个字段构成的数据记录，每个表保存在一个单独的文件中。表中的每一条记录可以通过搜索键查找到，为了能快速从文件中查找到对应记录，数据库系统使用索引。索引实际上是一种特殊的数据结构，它可以帮助在数据文件中快速定位数据记录，而且不需要扫描整个数据文件中的所有数据记录。通常索引会在一个或一组能够能识别数据记录的字段上构建。 通常数据库系统的数据记录和索引是分别存储到不同文件中的：数据文件存储数据记录；而索引文件索引数据。索引文件通常比数据文件小，通过索引文件中的数据就可以快速定位数据文件中记录位置。 数据文件数据文件（有时称为主文件（primary file））通常可以用索引组织表（Index-Organized Table，IOT）、堆组织表（heap-organized table，即堆文件）或哈希组织表（hash-organized table，即哈希文件）来实现。 堆组织表(heap-organized tables)，记录不需要遵循任何特定的顺序，并且大多数情况下它们都是按写顺序放置的。这样，在追加新的页时，数据库便不需要额外的工作或文件重组。堆文件需要额外的索引结构来指向存储数据记录的位置，以使其能够被检索到。(Oracle, PostgreSQL) 哈希组织表（hash-organized tables），记录存储在桶中，并且键的哈希值确定记录属于哪个桶。存储在桶中的记录可以按追加顺序存储，也可以按键排序存储以提高查找速度。 索引组织表(Index-Organized Table) 将索引和数据记录存储在一起。由于记录是按键的顺序存储的，所以索引组织表中的范围扫描可以通过顺序扫描其内容来实现。(innoDB) 索引文件索引是一种能帮助高效磁盘数据检索的数据结构。通常索引具有特殊的数据结构，该结构能映射键到键对应数据记录在数据文件中的位置。 主文件(数据文件)上的索引称为主索引。在大多数情况下，主索引构建在主键上，主键可以是一个键也可以是一组能标识记录的键。所有其他索引都称为辅助索引（Secondary indexes）。 辅助索引可以直接映射到数据记录位置，或者只是简单的映射到记录所对应的主键。多个辅助索引可以指向相同的记录，从而允许通过不同的字段和不同的索引来查找单个数据记录。主索引文件为每个搜索键保存唯一一个条目，而次索引可能为每个搜索键保存多个条目。 如果数据记录的顺序和搜索键的顺序一致，则此索引称为聚簇索引。这种情况下索引和的数据记录通常存储在相同的文件中。如果数据存储在单独的文件中，并且其顺序和键的顺序不一致，则该索引称非聚簇索引。 许多数据库系统都有自带显式主键对应唯一一条数据库记录。在没有指定主键的情况下，存储引擎可以创建一个隐式主键(如，MySQL InnoDB会添加一个自动递增列)。 辅助索引 直接通过文件偏移量引用数据记录 通过主键索引引用数据记录 通过直接引用数据，我们可以减少查找磁盘的次数，但在维护过程中，每当更新或重新定位记录时，我们都必须承担更新指针所带来的成本。通过主索引间接引用数据可以降低指针更新的成本，但在读取路径上成本更高。 为了减少指针更新的成本，一些数据库的具体实现是使用主键进行间接操作，而不是直接使用数据偏移量。例如，MySQL InnoDB使用主索引并执行两次查找：一次在二级索引中，一次在主索引中。这样并不直接使用二级索引查询得到的偏移量，因此增加了一次主索引的查询开销。 存储结构的分类 In-place update structure: 就地更新结构，如B树、B+树，直接覆盖旧记录来存储更新内容。 Out-of-place update structure：异位更新结构，如LSM树，会将更新的内容存储到新的位置，不覆盖旧的条目。 就地更新结构B树，B+树等，只会存储每个记录的最新版本，一般读性能优，写入代价比较大，因为更新会导致随机IO；在早期机械硬盘结构上表现最好，所以占据了主流。 异位更新结构LSM树，顺序写，写入性能更优，读取性能不太好。 SSD 上有两个显著的优势，第一个是 SSD 没有寻到时间，相比机械硬盘读性能有了很大的提升，很大程度上弥补了 lsm 数读取性能弱这一短板。第二点，SSD是基于闪存进行存储的，但闪存不能覆盖写，闪存块需要擦除才能够写入。而 lsm 数而 lsm 数追加写的写入模式天然契合了 SSD 的这种特性，从而很大程度上节省了擦除的损耗，并提升了 SSD 的使用寿命。 注意存储系统中一个重要的权衡：精心选择的索引加快了读查询的速度，但是每个索引都会拖慢写入速度。"},{"title":"给现有的项目中添加一个文档工具","date":"2022-07-27T16:00:00.000Z","url":"/2022/07/28/%E7%BB%99%E7%8E%B0%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/","tags":[["typescript","/tags/typescript/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["typescript","/categories/typescript/"]],"content":"背景前端项目开发到一定程度，各种抽象出来的组件就变得难以识别和维护，这时候就急需一个文档工具，理论上集成一下docz或者dumi即可，但是这两个项目由于依赖冲入，配置冲突，资源加载等原因集成进去已有的项目是非常困难的，各种报错。 造轮子思路在现有的背景下自己根据需求实现一个是比较理想的，以umi项目为例，只需要将src/components/myComponent 目录下的mdx文件转换为react组件即可，然后新开一个路由将转换的react组件全部加载进来即可。 转换组件首先需要转换和解析组件： 批量转换脚本约定：每个组件中的文档文件命名为doc.mdx，转换后的文档文件命名为doc.js,这样将每个组件下的文档文件进行批量转换： 文档路由切换.umirc.ts文件修改 package.json文件添加doc命令 这样执行npm run doc 时，可以快速仅启动文档路由 路由文件加入动态生成路由文件后就基本完成任务了，现在只需要关注编写mdx文档了。 "},{"title":"初始化一个ts-jest项目","date":"2022-07-25T16:00:00.000Z","url":"/2022/07/26/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAts-jest%E9%A1%B9%E7%9B%AE/","tags":[["typescript","/tags/typescript/"],["nodejs","/tags/nodejs/"]],"categories":[["typescript","/categories/typescript/"]],"content":"全局安装typescript 初始化typescript配置 配置类型声明和构建后目录 添加jest和ts-node等依赖"},{"title":"用ts自制解释器1","date":"2022-07-25T16:00:00.000Z","url":"/2022/07/26/%E7%94%A8ts%E8%87%AA%E5%88%B6%E8%A7%A3%E9%87%8A%E5%99%A81/","tags":[["typescript","/tags/typescript/"],["编译原理","/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"],["解释器","/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"]],"categories":[["编译原理","/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"]],"content":"背景最近在读《用Go语言自制解释器》，由于对Go语言不是很熟悉，所以在阅读的过程中决定用typescript将代码实现一遍，加深印象。 词法分析器要解释源代码，就需要对其转换成易于处理的形式，一般的步骤是： 第一步是用词法分析器将源代码转换为词法单元 ，这一 过程称为词法分析。词法分析器也称词法单元生成器或扫描器。 词法分析器本身是短小，易于分类的数据结构，它会被传给语法分析器，语法分析器会将词法单元转换成抽象语法树。 Monkey语言要解释的Monkey语言如下所示： 词法分析器实现思路 整体思路： 对源码进行挨个读取，去掉空格换行符等，然后进行分类： 关键字（let if else）、操作符（+ - * /）、分隔符（, ; ( ) &#123; &#125;）、标识符（ add x y params）、数字（123 45）等。然后将读取的结果放到一个数组中，等待交给下一步的语法分析器处理。 这个过程主要是个体力活，没什么技巧，先枚举出所有的词法单元，然后词法分析器会遍历输入的字符，然后逐个输出识别出的词法单元，对于Monkey语言，所有的词法分类如下： Repl用ts编写一个Repl: 代码实现ts-monkey"},{"title":"go学习笔记","date":"2022-07-10T16:00:00.000Z","url":"/2022/07/11/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["go","/tags/go/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["go","/categories/go/"]],"content":"go基本命令 go get: 获取远程包（需要提取安装git或gh） go run: 直接运行程序 go build: 测试编译，检查编译是否有错误 go fmt: 格式化源码 go install: 编译包文件并编译整个程序 go test: 运行测试文件（文件以_test.go结尾的默认为测试文件） go doc: 查看文档 Go modules newnew() 内建函数取指针，相当于结构体初始化后取指针，写法更简洁一些。 互斥锁sync.Mutex是一个互斥锁，可以由不同的goroutine加锁和解锁。 Go标准库提供了sync.Mutex互斥锁类型以及两个方法分别是Lock加锁和Unlock释放锁。可以通过在代码前调用Lock方法，在代码后调用Unlock方法来保证一段代码的互斥执行，也可以使用defer语句来保证互斥锁一定会被解锁。当一个goroutine调用Lock方法获得锁后，其它请求的goroutine都会阻塞在Lock方法直到锁被释放。 一个互斥锁只能同时被一个goroutine锁定，其它goroutine将阻塞直到互斥锁被解锁，也就是重新争抢对互斥锁的锁定。需要注意的是，对一个未锁定的互斥锁解锁时将会产生运行时错误。 sync.Mutex不区分读写锁，只有Lock()和Lock()之间才会导致阻塞的情况。 有互斥锁 没有互斥锁 "},{"title":"windows开发环境搭建","date":"2022-06-27T16:00:00.000Z","url":"/2022/06/28/windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":[["环境配置","/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"],["windows","/tags/windows/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"包管理工具 chocopowershell中执行 用包管理工具安装make notion host yarn相关 npm 相关"},{"title":"站在React的角度理解React","date":"2022-05-16T16:00:00.000Z","url":"/2022/05/17/%E7%AB%99%E5%9C%A8React%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3React/","tags":[["React","/tags/React/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["React","/categories/React/"]],"content":"前言本文基于建造属于你的react 这篇文章整理出来React的简单实现过程和一些核心概念，具体的细节和实现过程请参考原文。 React渲染过程中有两个重要的对象 ReactElement 对象和 fiber 对象 ReactElement 对象 所有采用jsx语法书写的节点, 都会被编译器转换, 最终会以React.createElement(...)的方式, 创建出来一个与之对应的ReactElement对象。 ReactElement对象可以理解为jsx语法的翻译。 fiber 对象 fiber对象是通过ReactElement对象进行创建的, 多个fiber对象构成了一棵fiber树, fiber树是构造DOM树的数据模型, fiber树的任何改动, 最后都可以体现到DOM上。 为什么要引入fiber树呢，是因为如果直接用ReactElement对象渲染页面的话，只能一次递归处理完，这样浏览器呈现卡死的状态，但是使用fiber树渲染页面可以随时中断，将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。 ReactElement 对象jsx 转换为原生 js 需要通过一些诸如babel的编译工具。编译的过程把所有元素标签部分所有内容转换为 React.createElement(...)函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。 例如如下的jsx节点： 最终会被React.createElement(...)转化成如下的一个对象返回： fiber 对象当 dom tree 很大的情况下，直接用ReactElement 对象渲染页面，页面上会是长时间的卡住状态，无法进行用户输入等交互操作。 可分为以下步骤解决上述问题： 允许中断渲染工作，如果有优先级更高的工作插入，则暂时中断浏览器渲染，待完成该工作后，恢复浏览器渲染； 将渲染工作进行分解，分解成一个个小单元； 步骤1可以使用浏览器的requestIdleCallbackAPI解决允许中断渲染工作的问题，步骤2就需要引入feiber对象处理了。 假设需要渲染上述ReactElement 对象，生成的 fiber树如图： fiber 树的目标是非常容易找到下一个单元工作，这也是为什么每一个 fiber 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 fiber 上面的工作后，fiber 拥有 child 属性可以直接指向下一个需要进行工作的 fiber 节点。 当 fiber节点没有child也没兄弟节点时，我们去他们的叔叔（父节点的兄弟节点）节点，如果fiber的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次render我们完成了所有的工作。 具体的渲染流程了解了两个最重要的对象和requestIdleCallbackAPI后，React内部的渲染逻辑可以简单抽象为这样： 按照这个流程其实React第一次渲染时并不快，因为要额外生成fiber树，但是依靠fiber树这个数据结构，React更新是很快的，因为React保留了上次渲染完的fiber树。 State的简单处理可以将State的信息挂在到当前的fiber对象中，这样每次SetState时，重新触发一次workloop就可以了。 后记这里只是针对建造属于你的react 这篇文章做了简单的总结，具体的实现细节还是建议先把建造属于你的react 这篇文章过一遍。 参考1 建造属于你的react - 唐鼎的个人博客 (tangdingblog.cn) 2 这可能是最通俗的 React Fiber 打开方式 (qq.com) 3 高频对象 - 图解React (7kms.github.io)"},{"title":"站在Vue2的角度理解Vue2","date":"2022-05-04T16:00:00.000Z","url":"/2022/05/05/%E7%AB%99%E5%9C%A8Vue2%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Vue2/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"前言Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。 核心原理Vue2的核心原理相对简单些，主要通过Object.defineProperty 对数据进行拦截，一个简单的数据拦截例子如下，会拦截Person对象上的name属性进行处理。 自定义实现代码自定义vuejs部分 相关html 参考 Vue.js 数据双向绑定的原理及实现 "},{"title":"添加索引和二进制格式存储（数据库的简单实现2）","date":"2022-03-15T16:00:00.000Z","url":"/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A82/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["数据库的简单实现2","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B02/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"索引索引是从主数据衍生出来的额外结构，添加和删除索引完全不会影响数据，只会影响查询的性能。维护这个结构会产生一些开销，因为需要在写入的时候多做一点操作，去更新索引，这样才能在读取的时候利用索引来加快一点速度。任何类型的索引通常都会减慢写入速度，因此数据库默认并不会索引所有的内容，而是需要用户来根据自己的情况做出取舍来手动选择索引，尽量选择那些带来较大收益而且又不会引入超出必要开销的索引。 哈希索引之前实现的简单数据库，可以使用Map来索引文件中的数据，假设依然是追加写入的文件，和之前一样，可以设计一个最简单的索引策略：保留一个内存中的散列映射，其中每个键都映射到数据文件中的一个字节偏移量，指明了可以找到对应值的位置。 为数据库加上索引并把存储格式改为二进制接下来开始实现一个最简单的保存在内存中的哈希索引，这在 Node 环境中非常简单，只需要用一个 Map就可以。数据存储为二进制后，可以将数据看成一个大的数组，读取数据只需要知道数据的下标和数据的大小就可以: 对于不同的数据类型，需要针对性的将其转换为二进制，简单起见，暂时只支持三种数据类型，分别是数字、布尔值和字符串: 针对这三个类型编写一个序列化的函数，同时，为了在读取时针对性的进行反序列化，我们还需要将它的类型信息也存进去，规则是下面这样的： 每一个数据都用第一个字节来存储它的类型信息，0，1，2 分别对应布尔值，数字和字符串； 布尔值，用一个字节来表示（主要是 Node 最少得分配一个字节），1 为 true，0 为 false； 数字，因为 Node 中的普通数字实际上都是双精度浮点数，我们就将其都作为 double 处理，占用 8 个字节（64 位），对于可能溢出的大数字先不管； 除了布尔和数字，其他都当做字符串处理，采用 UTF-8 编码。 注意数字的部分用到了 buffer.writeDoubleBE，BE的意思是 Big-Endian，中文叫大端序，还有一种叫小端序，对于字节序这里不赘述。具体使用什么样的字节序没什么讲究，重要的是在序列化和反序列化的时候一定要使用相同的字节序，这里我们默认全部使用大端序。 反序列化也很简单： 整体的思路就确定了： 启动时先获取数据库文件 fd，开启 repl 环境； 对于 set 命令把 key&#x2F;value 交给 set 函数，进行序列化，先更新索引，再写入文件； 对于 get 命令解析出 key，交给 get 函数，先从索引中查找，如果有的话根据偏移位置和数据大小，然后直接读取出来并进行反序列化然后返回。 可以重构一下之前的 get和 set函数： 使用 ts-node main.ts来直接启动并进行测试。 最后附上完整的代码： 参考Build a simple database with Node.js (db-js.vercel.app)"},{"title":"最简单的K-V数据库后端实现（数据库的简单实现1）","date":"2022-03-08T16:00:00.000Z","url":"/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E7%AE%80%E5%8D%95%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%931/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["数据库的简单实现","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"这里将用TypeScript开始实现一个最简单的 Key-Value 数据库，以理解数据库是怎么工作的。 建立 REPL 环境首先要建立建立 REPL 环境，这样就可以在终端输入语句，然后查看输出，并不断进行这个循环直到停止使用。 Node.js 的标准库本身提供了一个叫 repl的模块，只需要几行代码，就可以非常迅速的建立起一个 REPL 环境。 使用 ts-node这样的工具来直接运行这个文件，就可以跑起来了。为了测试，试试输入 test并回车，可以看到下面这样的输出： 最简单的实现实现一个将数据存储到硬盘上的数据库，这样即使进程退出数据也不会丢失。 实现思路：直接把数据序列化以后作为文本塞到文件的最后，同时把键和值用逗号分割。每当读取数据时，扫描这个文件来一行一行遍历查询键名。 然后简单的修改一下 eval 参数以接入 set 和 get 接口，可以先不管解析 SQL 语句之类的事情，使用一个最简单的语法， set [key] [value] get [key] 语法的解析也是暂时假定所有的输入都是正确的格式，这样可以用非常简单的方式来实现： 启动以后测试一下，可以看到已经成功了： set 函数在简单的场景性能其实非常好，因为在文件尾部追加写入其实是很高效的，像很多日志的实现，都是一个 append-only 的文件，虽然还有像并发，容错等很多额外的事情要处理，但核心原理是一样的。 但对于读取数据的 get 操作，它的性能则非常糟糕，因为每次必须从头到尾扫描整个文件来进行查找。从算法的角度来说，它的复杂度是 O(N) 。也就是说随着数据量的增大，查找的时间也会线性增长。要解决这个问题，需要引入一个叫 索引 的额外结构，比如查汉语字典时，可以根据偏旁部首或者拼音，在目录中找到他们的大概位置，直接翻到那一页再仔细一条条查找，索引的概念和目录就是一样的。 同时还有一个问题，在存储时将所有的值序列化为字符串再作为文本直接写入到文件中，同时使用逗号分隔键和值，这个叫 CSV (comma-separated values) 格式，写入时会默认使用 UTF-8 的编码格式，每一个 UTF-8 字符会使用 1-4 个字节来存储，但对某些值来说，将其转化成字符串有可能会增大它的体积，例如布尔值完全可以用一个 bit 位来代替，而转变成了字符串 “true” 在 UTF-8 中则变成了 4 个字节。 使用文本格式的最大优点，是提供给了人类一个很好的可读性，事实上 MySQL 确实就有一个CSV 存储引擎。但在绝大多数情况下，文本格式并不是一个最佳选择，毕竟提供给人类可读性并不是一个很高优的目标，而使用二进制格式能有更好的性能表现。 虽然用 Node.js 来实现肯定不会有太好的性能，但这个学习过程中会像设计一个真正的数据库一样去思考。在 Node 中可以利用 [Buffer]() 来实现对二进制数据进行操作，因此后续会将文本格式改为二进制格式。 最后附上完整的代码： 参考Build a simple database with Node.js (db-js.vercel.app)"},{"title":"从神策小程序SDK中学习小程序数据收集","date":"2022-02-08T16:00:00.000Z","url":"/2022/02/09/%E4%BB%8E%E7%A5%9E%E7%AD%96%E5%B0%8F%E7%A8%8B%E5%BA%8FSDK%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86/","tags":[["小程序","/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["小程序","/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"背景业务需求，需要收集用户在小程序端的特定行为（页面浏览时长，点击行为等）。 初始实现刚开始是根据业务需求，在小程序端特定页面或者特定的事件上添加函数处理，重复代码多，每次修改很麻烦。 神策的实现在同事的帮助下看了神策收集数据的方式，将小程序特定行为数据的收集写成可配置的，大大减少了重复代码，提高了代码可维护性。 神策SDK中的简单实现小程序根据组件级别可以分为App、Page和Component。 App 监听App的显示和隐藏比较简单，小程序有提供专门的API Page 在app.js中，App.onLaunch 中重写下Page，以记录进入每个页面的浏览时长为例： 其他的点击事件或者页面事件类似，都可以写成这种可配置的方式 Component Component和Page类似，在App.onLaunch 中重写下Component，然后处理Component事件或者点击事件 参考sa-sdk-miniprogram"},{"title":"在 Windows Git Bash 中安装 Zsh","date":"2022-01-17T16:00:00.000Z","url":"/2022/01/18/%E5%9C%A8%20Windows%20Git%20Bash%E4%B8%AD%E5%AE%89%E8%A3%85Zsh/","tags":[["环境配置","/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"],["windows","/tags/windows/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"在 Git Bash 中安装 Zsh 从 MSYS2 软件包存储库 下载最新的MSYS2zsh 软件包。该文件将被命名为 类似于 .zsh-5.8-5-x86_64.pkg.tar.zst 解压下载文件到 Git Bash 安装目录中 C:\\Program Files\\Git 打开 Git Bash 并运行 重要说明：在 Zsh 首次使用向导中配置选项卡完成和历史记录。如果由于某种原因它没有出现，或者您跳过了它，请重新运行它： 若要配置历史记录，请按 ，根据需要按 更改值，然后按 。11-30 要配置完成，请按”使用新的完成系统”，然后按 。20 按以保存设置。0 会出现一行报错：ERROR: this script is obsolete, please see git-completion.zsh删除文件 /etc/profile.d/git-prompt.sh 即可 通过将以下内容附加到您的文件，将 Zsh 配置为默认 shell：~/.bashrc 安装 oh-my-zsh 安装插件和主题 修改插件 安装zsh-syntax-highlighting 安装zsh-autosuggestions 注意：终端中可能会出现奇怪的伪影和间距。要解决此问题，请使用版本：v0.7.0v.0.6.4 cd ~/.oh-my-zsh/plugins/zsh-autosuggestions git checkout tags/v0.6.4 -b v0.6.4-branch 参考 Installing Zsh (and oh-my-zsh) in Windows Git Bash Git-Zsh on Windows安装与配置 oh-my-zsh 国内安装及配置 "},{"date":"2022-08-04T10:10:47.755Z","url":"/category/index.html","categories":[[" ",""]]},{"date":"2022-08-04T10:09:02.585Z","url":"/tags/index.html","categories":[[" ",""]]},{"date":"2022-08-04T10:11:31.210Z","url":"/search/index.html","categories":[[" ",""]]}]