[{"date":"2022-09-06T03:39:23.613Z","url":"/2022/09/06/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E6%A3%80%E7%B4%A2/","categories":[[" ",""]],"content":"数据存储与检索Created: August 24, 2022 8:49 PMTags: 文档 数据存储与检索背景数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 维度 OLTP(online transaction processing) OLAP(online analysis processing) 系统功能 日常交易处理&#x2F;在线失误处理 统计、分析、报表&#x2F;在线分析处理 设计目标 面向实时交易类应用 面向统计分析类应用 数据处理 当前的、最新的 历史的、聚集的 实时性 实时性读写要求高 实时性读写要求低 事务 强事务 弱事务 分析要求 低、简单 高、复杂 OLTP大多数OLTP系统中，数据存储都是以面向行(row-oriented)的方式组织的。这种方式把一行数据存放在一起。在OLAP系统中，查询语句一般是获取大量行数据中的特定某几列。 OLTP的存储引擎分为面向页（b+tree）存储引擎和日志结构（lsm tree）存储引擎 基于页（b+tree）的存储引擎背景对于数据存储这个场景来说，数据量一般大到无法放进机器的内存中，是需要放在磁盘上的，因此必须要有一个基于磁盘的数据结构，我们一次只加载一小点进来用于缓存或者比较，而绝大部分的数据都继续放在磁盘上。 需要设计一个基于磁盘的数据结构，势必要求对硬件有一定的了解的，事实上硬件也确实会很大程度上影响到软件的设计，绝大多数老牌数据库的设计都受到当时主流的机械硬盘设计的影响。 机械硬盘读写数据的时间：寻道时间+旋转时间+传输时间： 寻道时间：8ms~12ms 旋转时间：7200转&#x2F;min：半周4ms 传输时间：50M&#x2F;s，约0.3ms 机械硬盘最小的读写单位是一个扇区(Sector)，一般大概是在 512 bytes 到 4kb 之间。 理论限制： 每次针对磁盘的读写操作都基于一小块，而不是单独的一个字节 每次读写一块内容都比较慢 数据结构设计，直接抛结论： B+ 树。 B+ 树是一种树数据结构，通常用于数据库和操作系统的文件系统中。B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+树节点结构 在B+树中的节点通常被表示为一组有序的元素和子指针。如果此B+树的阶数是m，则除了根之外的每个节点都包含最少 m&#x2F;2 个元素最多 m−1个元素，对于任意的结点有最多 m 个子指针。对于所有内部节点，子指针的数目总是比元素的数目多一个。所有叶子都在相同的高度上，叶结点本身按关键字大小从小到大链接。 数据结构中的B+树 实践总结基于b+树的存储引擎 为什么是b+树 背景 读多写少的场景 数据按行组织 存储千万条数据 高性价比存储 （存储介质成本低、容量大） 磁盘访问时间：寻道时间+旋转时间+传输时间 寻道时间： 8ms-12ms 旋转时间：7200转&#x2F;min 一周8.3ms 半周4ms 传输时间：50M&#x2F;s 约0.3ms 磁盘随机IO &lt;&lt;磁盘顺序IO &#x3D;&#x3D;内存随机IO&lt;&lt;内存顺序IO 以操作系统的页大小为基本块单位 4k 机械硬盘有点类似唱片机一样的有着圆形盘片和读写头，在读写数据时需要让读写头先找到特定的位置，这个叫寻道，然后才能开始读写数据，也就是说随机访问会存在一定的成本，但接下来的顺序读写会相对很快。机械硬盘最小的读写单位是一个 Sector，一般大概是在 512 bytes 到 4kb 之间。 而固态硬盘（SSD）就没有这样的物理结构，它使用闪存芯片来作为存储单元，而闪存会分为固定的区块为单位进行管理： 其中最小可写入的区块是一个 Page，一般在 2- 16 kb 之间，而最小可以擦除的区块，是一个 Block，一个 Block 可能会包含 64 到 512 个 Page。 对于这二者来说，有一个共同点就是我们的读写操作每次都是需要基于一小块内容的，而不是单独的一个个字节。 因此设计针对磁盘的数据结构时，我们最好利用这个特点，也像磁盘的设计一样，去读写固定一小块完整的内容，而不是任意字节大小的内容，这一块内容里可以包含一个指针，告诉我们下一次需要读取的内容在哪个位置，然后再到那个位置再把一整块内容读取进来。 b+树特征 最底层的页保存记录完整数据，每页保存多条数据 中间页保存索引信息（页编号、该页存储的最小记录） 结论 内存和磁盘都可以维护的数据结构：b+树， 核心原因 树高度低，每次磁盘IO相对较少，不同请求时间复杂度比较平均 基于日志结构存储的存储引擎"},{"title":"给现有的项目中添加一个文档工具","date":"2022-07-27T16:00:00.000Z","url":"/2022/07/28/%E7%BB%99%E7%8E%B0%E6%9C%89%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/","tags":[["typescript","/tags/typescript/"],["工具","/tags/%E5%B7%A5%E5%85%B7/"]],"categories":[["typescript","/categories/typescript/"]],"content":"背景前端项目开发到一定程度，各种抽象出来的组件就变得难以识别和维护，这时候就急需一个文档工具，理论上集成一下docz或者dumi即可，但是这两个项目由于依赖冲入，配置冲突，资源加载等原因集成进去已有的项目是非常困难的，各种报错。 造轮子思路在现有的背景下自己根据需求实现一个是比较理想的，以umi项目为例，只需要将src/components/myComponent 目录下的mdx文件转换为react组件即可，然后新开一个路由将转换的react组件全部加载进来即可。 转换组件首先需要转换和解析组件： 批量转换脚本约定：每个组件中的文档文件命名为doc.mdx，转换后的文档文件命名为doc.js,这样将每个组件下的文档文件进行批量转换： 文档路由切换.umirc.ts文件修改 package.json文件添加doc命令 这样执行npm run doc 时，可以快速仅启动文档路由 路由文件加入动态生成路由文件后就基本完成任务了，现在只需要关注编写mdx文档了。 "},{"title":"初始化一个ts-jest项目","date":"2022-07-25T16:00:00.000Z","url":"/2022/07/26/%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AAts-jest%E9%A1%B9%E7%9B%AE/","tags":[["typescript","/tags/typescript/"],["nodejs","/tags/nodejs/"]],"categories":[["typescript","/categories/typescript/"]],"content":"全局安装typescript 初始化typescript配置 配置类型声明和构建后目录 添加jest和ts-node等依赖"},{"title":"用ts自制解释器1","date":"2022-07-25T16:00:00.000Z","url":"/2022/07/26/%E7%94%A8ts%E8%87%AA%E5%88%B6%E8%A7%A3%E9%87%8A%E5%99%A81/","tags":[["typescript","/tags/typescript/"],["编译原理","/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"],["解释器","/tags/%E8%A7%A3%E9%87%8A%E5%99%A8/"]],"categories":[["编译原理","/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"]],"content":"背景最近在读《用Go语言自制解释器》，由于对Go语言不是很熟悉，所以在阅读的过程中决定用typescript将代码实现一遍，加深印象。 词法分析器要解释源代码，就需要对其转换成易于处理的形式，一般的步骤是： 第一步是用词法分析器将源代码转换为词法单元 ，这一 过程称为词法分析。词法分析器也称词法单元生成器或扫描器。 词法分析器本身是短小，易于分类的数据结构，它会被传给语法分析器，语法分析器会将词法单元转换成抽象语法树。 Monkey语言要解释的Monkey语言如下所示： 词法分析器实现思路 整体思路： 对源码进行挨个读取，去掉空格换行符等，然后进行分类： 关键字（let if else）、操作符（+ - * /）、分隔符（, ; ( ) &#123; &#125;）、标识符（ add x y params）、数字（123 45）等。然后将读取的结果放到一个数组中，等待交给下一步的语法分析器处理。 这个过程主要是个体力活，没什么技巧，先枚举出所有的词法单元，然后词法分析器会遍历输入的字符，然后逐个输出识别出的词法单元，对于Monkey语言，所有的词法分类如下： Repl用ts编写一个Repl: 代码实现ts-monkey"},{"title":"go学习笔记","date":"2022-07-10T16:00:00.000Z","url":"/2022/07/11/go%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["go","/tags/go/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["go","/categories/go/"]],"content":"go基本命令 go get: 获取远程包（需要提取安装git或gh） go run: 直接运行程序 go build: 测试编译，检查编译是否有错误 go fmt: 格式化源码 go install: 编译包文件并编译整个程序 go test: 运行测试文件（文件以_test.go结尾的默认为测试文件） go doc: 查看文档 Go modules"},{"title":"windows开发环境搭建","date":"2022-06-27T16:00:00.000Z","url":"/2022/06/28/windows%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":[["环境配置","/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"],["windows","/tags/windows/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"包管理工具 chocopowershell中执行 用包管理工具安装make notion host yarn相关 npm 相关"},{"title":"站在React的角度理解React","date":"2022-05-16T16:00:00.000Z","url":"/2022/05/17/%E7%AB%99%E5%9C%A8React%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3React/","tags":[["React","/tags/React/"],["前端","/tags/%E5%89%8D%E7%AB%AF/"]],"categories":[["React","/categories/React/"]],"content":"前言本文基于建造属于你的react 这篇文章整理出来React的简单实现过程和一些核心概念，具体的细节和实现过程请参考原文。 React渲染过程中有两个重要的对象 ReactElement 对象和 fiber 对象 ReactElement 对象 所有采用jsx语法书写的节点, 都会被编译器转换, 最终会以React.createElement(...)的方式, 创建出来一个与之对应的ReactElement对象。 ReactElement对象可以理解为jsx语法的翻译。 fiber 对象 fiber对象是通过ReactElement对象进行创建的, 多个fiber对象构成了一棵fiber树, fiber树是构造DOM树的数据模型, fiber树的任何改动, 最后都可以体现到DOM上。 为什么要引入fiber树呢，是因为如果直接用ReactElement对象渲染页面的话，只能一次递归处理完，这样浏览器呈现卡死的状态，但是使用fiber树渲染页面可以随时中断，将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。 ReactElement 对象jsx 转换为原生 js 需要通过一些诸如babel的编译工具。编译的过程把所有元素标签部分所有内容转换为 React.createElement(...)函数，给函数传递元素标签名，标签上面的属性（prop），以及标签的子节点（children）。 例如如下的jsx节点： 最终会被React.createElement(...)转化成如下的一个对象返回： fiber 对象当 dom tree 很大的情况下，直接用ReactElement 对象渲染页面，页面上会是长时间的卡住状态，无法进行用户输入等交互操作。 可分为以下步骤解决上述问题： 允许中断渲染工作，如果有优先级更高的工作插入，则暂时中断浏览器渲染，待完成该工作后，恢复浏览器渲染； 将渲染工作进行分解，分解成一个个小单元； 步骤1可以使用浏览器的requestIdleCallbackAPI解决允许中断渲染工作的问题，步骤2就需要引入feiber对象处理了。 假设需要渲染上述ReactElement 对象，生成的 fiber树如图： fiber 树的目标是非常容易找到下一个单元工作，这也是为什么每一个 fiber 节点都有指向第一个节点和相邻节点以及父节点的链接。当我们完成在 fiber 上面的工作后，fiber 拥有 child 属性可以直接指向下一个需要进行工作的 fiber 节点。 当 fiber节点没有child也没兄弟节点时，我们去他们的叔叔（父节点的兄弟节点）节点，如果fiber的父节点也没有兄弟节点，我们继续往上找父节点的兄弟节点直到到根节点。当我们到根节点的时候，也意味着在这一次render我们完成了所有的工作。 具体的渲染流程了解了两个最重要的对象和requestIdleCallbackAPI后，React内部的渲染逻辑可以简单抽象为这样： 按照这个流程其实React第一次渲染时并不快，因为要额外生成fiber树，但是依靠fiber树这个数据结构，React更新是很快的，因为React保留了上次渲染完的fiber树。 State的简单处理可以将State的信息挂在到当前的fiber对象中，这样每次SetState时，重新触发一次workloop就可以了。 后记这里只是针对建造属于你的react 这篇文章做了简单的总结，具体的实现细节还是建议先把建造属于你的react 这篇文章过一遍。 参考1 建造属于你的react - 唐鼎的个人博客 (tangdingblog.cn) 2 这可能是最通俗的 React Fiber 打开方式 (qq.com) 3 高频对象 - 图解React (7kms.github.io)"},{"title":"站在Vue2的角度理解Vue2","date":"2022-05-04T16:00:00.000Z","url":"/2022/05/05/%E7%AB%99%E5%9C%A8Vue2%E7%9A%84%E8%A7%92%E5%BA%A6%E7%90%86%E8%A7%A3Vue2/","tags":[["前端","/tags/%E5%89%8D%E7%AB%AF/"],["Vue","/tags/Vue/"]],"categories":[["Vue","/categories/Vue/"]],"content":"前言Vue 最独特的特性之一，是其非侵入性的响应式系统。数据模型仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。 核心原理Vue2的核心原理相对简单些，主要通过Object.defineProperty 对数据进行拦截，一个简单的数据拦截例子如下，会拦截Person对象上的name属性进行处理。 自定义实现代码自定义vuejs部分 相关html 参考 Vue.js 数据双向绑定的原理及实现 "},{"title":"添加索引和二进制格式存储（数据库的简单实现2）","date":"2022-03-15T16:00:00.000Z","url":"/2022/03/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E5%AD%98%E5%82%A82/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["数据库的简单实现2","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B02/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"索引索引是从主数据衍生出来的额外结构，添加和删除索引完全不会影响数据，只会影响查询的性能。维护这个结构会产生一些开销，因为需要在写入的时候多做一点操作，去更新索引，这样才能在读取的时候利用索引来加快一点速度。任何类型的索引通常都会减慢写入速度，因此数据库默认并不会索引所有的内容，而是需要用户来根据自己的情况做出取舍来手动选择索引，尽量选择那些带来较大收益而且又不会引入超出必要开销的索引。 哈希索引之前实现的简单数据库，可以使用Map来索引文件中的数据，假设依然是追加写入的文件，和之前一样，可以设计一个最简单的索引策略：保留一个内存中的散列映射，其中每个键都映射到数据文件中的一个字节偏移量，指明了可以找到对应值的位置。 为数据库加上索引并把存储格式改为二进制接下来开始实现一个最简单的保存在内存中的哈希索引，这在 Node 环境中非常简单，只需要用一个 Map就可以。数据存储为二进制后，可以将数据看成一个大的数组，读取数据只需要知道数据的下标和数据的大小就可以: 对于不同的数据类型，需要针对性的将其转换为二进制，简单起见，暂时只支持三种数据类型，分别是数字、布尔值和字符串: 针对这三个类型编写一个序列化的函数，同时，为了在读取时针对性的进行反序列化，我们还需要将它的类型信息也存进去，规则是下面这样的： 每一个数据都用第一个字节来存储它的类型信息，0，1，2 分别对应布尔值，数字和字符串； 布尔值，用一个字节来表示（主要是 Node 最少得分配一个字节），1 为 true，0 为 false； 数字，因为 Node 中的普通数字实际上都是双精度浮点数，我们就将其都作为 double 处理，占用 8 个字节（64 位），对于可能溢出的大数字先不管； 除了布尔和数字，其他都当做字符串处理，采用 UTF-8 编码。 注意数字的部分用到了 buffer.writeDoubleBE，BE的意思是 Big-Endian，中文叫大端序，还有一种叫小端序，对于字节序这里不赘述。具体使用什么样的字节序没什么讲究，重要的是在序列化和反序列化的时候一定要使用相同的字节序，这里我们默认全部使用大端序。 反序列化也很简单： 整体的思路就确定了： 启动时先获取数据库文件 fd，开启 repl 环境； 对于 set 命令把 key&#x2F;value 交给 set 函数，进行序列化，先更新索引，再写入文件； 对于 get 命令解析出 key，交给 get 函数，先从索引中查找，如果有的话根据偏移位置和数据大小，然后直接读取出来并进行反序列化然后返回。 可以重构一下之前的 get和 set函数： 使用 ts-node main.ts来直接启动并进行测试。 最后附上完整的代码： 参考Build a simple database with Node.js (db-js.vercel.app)"},{"title":"最简单的K-V数据库后端实现（数据库的简单实现1）","date":"2022-03-08T16:00:00.000Z","url":"/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E7%AE%80%E5%8D%95%E7%9A%84kv%E6%95%B0%E6%8D%AE%E5%BA%931/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["数据库的简单实现","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]],"content":"这里将用TypeScript开始实现一个最简单的 Key-Value 数据库，以理解数据库是怎么工作的。 建立 REPL 环境首先要建立建立 REPL 环境，这样就可以在终端输入语句，然后查看输出，并不断进行这个循环直到停止使用。 Node.js 的标准库本身提供了一个叫 repl的模块，只需要几行代码，就可以非常迅速的建立起一个 REPL 环境。 使用 ts-node这样的工具来直接运行这个文件，就可以跑起来了。为了测试，试试输入 test并回车，可以看到下面这样的输出： 最简单的实现实现一个将数据存储到硬盘上的数据库，这样即使进程退出数据也不会丢失。 实现思路：直接把数据序列化以后作为文本塞到文件的最后，同时把键和值用逗号分割。每当读取数据时，扫描这个文件来一行一行遍历查询键名。 然后简单的修改一下 eval 参数以接入 set 和 get 接口，可以先不管解析 SQL 语句之类的事情，使用一个最简单的语法， set [key] [value] get [key] 语法的解析也是暂时假定所有的输入都是正确的格式，这样可以用非常简单的方式来实现： 启动以后测试一下，可以看到已经成功了： set 函数在简单的场景性能其实非常好，因为在文件尾部追加写入其实是很高效的，像很多日志的实现，都是一个 append-only 的文件，虽然还有像并发，容错等很多额外的事情要处理，但核心原理是一样的。 但对于读取数据的 get 操作，它的性能则非常糟糕，因为每次必须从头到尾扫描整个文件来进行查找。从算法的角度来说，它的复杂度是 O(N) 。也就是说随着数据量的增大，查找的时间也会线性增长。要解决这个问题，需要引入一个叫 索引 的额外结构，比如查汉语字典时，可以根据偏旁部首或者拼音，在目录中找到他们的大概位置，直接翻到那一页再仔细一条条查找，索引的概念和目录就是一样的。 同时还有一个问题，在存储时将所有的值序列化为字符串再作为文本直接写入到文件中，同时使用逗号分隔键和值，这个叫 CSV (comma-separated values) 格式，写入时会默认使用 UTF-8 的编码格式，每一个 UTF-8 字符会使用 1-4 个字节来存储，但对某些值来说，将其转化成字符串有可能会增大它的体积，例如布尔值完全可以用一个 bit 位来代替，而转变成了字符串 “true” 在 UTF-8 中则变成了 4 个字节。 使用文本格式的最大优点，是提供给了人类一个很好的可读性，事实上 MySQL 确实就有一个CSV 存储引擎。但在绝大多数情况下，文本格式并不是一个最佳选择，毕竟提供给人类可读性并不是一个很高优的目标，而使用二进制格式能有更好的性能表现。 虽然用 Node.js 来实现肯定不会有太好的性能，但这个学习过程中会像设计一个真正的数据库一样去思考。在 Node 中可以利用 [Buffer]() 来实现对二进制数据进行操作，因此后续会将文本格式改为二进制格式。 最后附上完整的代码： 参考Build a simple database with Node.js (db-js.vercel.app)"},{"title":"数据库理论部分（数据库的简单实现3）","date":"2022-03-08T16:00:00.000Z","url":"/2022/03/09/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0-%E7%90%86%E8%AE%BA%E9%83%A8%E5%88%863/","tags":[["数据库","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"],["数据库的简单实现","/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"]],"categories":[["数据库","/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"]]},{"title":"从神策小程序SDK中学习小程序数据收集","date":"2022-02-08T16:00:00.000Z","url":"/2022/02/09/%E4%BB%8E%E7%A5%9E%E7%AD%96%E5%B0%8F%E7%A8%8B%E5%BA%8FSDK%E4%B8%AD%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86/","tags":[["小程序","/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"categories":[["小程序","/categories/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"]],"content":"背景业务需求，需要收集用户在小程序端的特定行为（页面浏览时长，点击行为等）。 初始实现刚开始是根据业务需求，在小程序端特定页面或者特定的事件上添加函数处理，重复代码多，每次修改很麻烦。 神策的实现在同事的帮助下看了神策收集数据的方式，将小程序特定行为数据的收集写成可配置的，大大减少了重复代码，提高了代码可维护性。 神策SDK中的简单实现小程序根据组件级别可以分为App、Page和Component。 App 监听App的显示和隐藏比较简单，小程序有提供专门的API Page 在app.js中，App.onLaunch 中重写下Page，以记录进入每个页面的浏览时长为例： 其他的点击事件或者页面事件类似，都可以写成这种可配置的方式 Component Component和Page类似，在App.onLaunch 中重写下Component，然后处理Component事件或者点击事件 参考sa-sdk-miniprogram"},{"title":"在 Windows Git Bash 中安装 Zsh","date":"2022-01-17T16:00:00.000Z","url":"/2022/01/18/%E5%9C%A8%20Windows%20Git%20Bash%E4%B8%AD%E5%AE%89%E8%A3%85Zsh/","tags":[["环境配置","/tags/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"],["windows","/tags/windows/"]],"categories":[["环境配置","/categories/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"]],"content":"在 Git Bash 中安装 Zsh 从 MSYS2 软件包存储库 下载最新的MSYS2zsh 软件包。该文件将被命名为 类似于 .zsh-5.8-5-x86_64.pkg.tar.zst 解压下载文件到 Git Bash 安装目录中 C:\\Program Files\\Git 打开 Git Bash 并运行 重要说明：在 Zsh 首次使用向导中配置选项卡完成和历史记录。如果由于某种原因它没有出现，或者您跳过了它，请重新运行它： 若要配置历史记录，请按 ，根据需要按 更改值，然后按 。11-30 要配置完成，请按”使用新的完成系统”，然后按 。20 按以保存设置。0 会出现一行报错：ERROR: this script is obsolete, please see git-completion.zsh删除文件 /etc/profile.d/git-prompt.sh 即可 通过将以下内容附加到您的文件，将 Zsh 配置为默认 shell：~/.bashrc 安装 oh-my-zsh 安装插件和主题 修改插件 安装zsh-syntax-highlighting 安装zsh-autosuggestions 注意：终端中可能会出现奇怪的伪影和间距。要解决此问题，请使用版本：v0.7.0v.0.6.4 cd ~/.oh-my-zsh/plugins/zsh-autosuggestions git checkout tags/v0.6.4 -b v0.6.4-branch 参考 Installing Zsh (and oh-my-zsh) in Windows Git Bash Git-Zsh on Windows安装与配置 oh-my-zsh 国内安装及配置 "},{"date":"2022-08-04T10:11:31.210Z","url":"/search/index.html","categories":[[" ",""]]},{"date":"2022-08-04T10:10:47.755Z","url":"/category/index.html","categories":[[" ",""]]},{"date":"2022-08-04T10:09:02.585Z","url":"/tags/index.html","categories":[[" ",""]]}]